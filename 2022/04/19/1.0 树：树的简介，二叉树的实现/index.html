<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>1.0 树：树的简介，二叉树的实现 | RetenQ的博客</title><meta name="keywords" content="算法,MIEC生存手册"><meta name="author" content="RetenQ"><meta name="copyright" content="RetenQ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对于树方面的简介，对于二叉树的介绍、实现原理、代码实现，基于《数据结构与算法分析_Java实现》，以及一部分的MIEC课程">
<meta property="og:type" content="article">
<meta property="og:title" content="1.0 树：树的简介，二叉树的实现">
<meta property="og:url" content="http://example.com/2022/04/19/1.0%20%E6%A0%91%EF%BC%9A%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="RetenQ的博客">
<meta property="og:description" content="对于树方面的简介，对于二叉树的介绍、实现原理、代码实现，基于《数据结构与算法分析_Java实现》，以及一部分的MIEC课程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg">
<meta property="article:published_time" content="2022-04-19T12:08:00.000Z">
<meta property="article:modified_time" content="2022-08-12T07:31:19.523Z">
<meta property="article:author" content="RetenQ">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="MIEC生存手册">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/01/12/FP23fqhJaZjYNLw.jpg"><link rel="canonical" href="http://example.com/2022/04/19/1.0%20%E6%A0%91%EF%BC%9A%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '1.0 树：树的简介，二叉树的实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-12 15:31:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="RetenQ的博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/08/12/AzsRr7yUNo5Ibhg.png" onerror="onerror=null;src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">RetenQ的博客</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1.0 树：树的简介，二叉树的实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-19T12:08:00.000Z" title="发表于 2022-04-19 20:08:00">2022-04-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-12T07:31:19.523Z" title="更新于 2022-08-12 15:31:19">2022-08-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/">MIEC生存手册</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="1.0 树：树的简介，二叉树的实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树&#x2F;自由树(tree&#x2F;free tree)是一个连通的、非循环的无向图   </p>
<h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>初步阐释了树，以及对于<strong>二叉树、AVL树的实现与分析</strong>。<br>最后简单介绍了红黑树、伸展树、B&#x2F;B+树，如果有需要&#x2F;有机会的话补充这三者的实现与分析(好复杂)   </p>
<h2 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h2><p>树有多种方式定义，其中一种自然的方式是采用递归<br>一棵树是一些点的集合，这个集合也能是空集；<br>若不为空集，树<strong>就由称作跟root的节点r，以及0到N个的非空(子)树组成，子树的每一棵的跟都有来自r的一条有向边连接</strong><br>在递归定义中，我们认为“一棵树是N个节点和N-1跳边的集合，其中一个节点为根root”    </p>
<h2 id="树与节点"><a href="#树与节点" class="headerlink" title="树与节点"></a>树与节点</h2><p>根节点：最初的节点，被称为根或根节点 Root&#x2F;Root Node<br>叶&#x2F;外节点:没有子节点的的点 Leaf&#x2F;External Node<br>内节点：非叶节点的其他节点 Internal Node</p>
<p>深度Depth:从根到节点的简单路径的长度<br>高度Height:一棵树的最大深度，对于任意节点ni,ni的深度到一片树叶的最远路径长<br>Degree 根节点的子节点数目<br><img src="https://s2.loli.net/2022/03/11/hVSWFYcX5wduPBj.png"> </p>
<p>节点祖先 Ancestor of a node：从根节点到指定节点的唯一简单路径上的任何节点<br>后代 Descendant: 如果A是B的祖先节点，则B是A的后代节点   </p>
<blockquote>
<p>每个节点都是自己的Ancestor和Descendant    </p>
</blockquote>
<p>父节点 Parent:从根节点到指定节点的简单路径上的最后一条边的那个点，则是指定节点的父节点。根节点是唯一没有父节点的节点 </p>
<p>同级节点 siblings:如果两个节点拥有相同的父节点，则它们是同级节点    </p>
<p>子树和子树根节点 :以节点为根的子树是由以节点为根的节点的后代生成的树  </p>
<p><img src="https://s2.loli.net/2022/03/11/nD4xcLWrpsUZFmz.png"> </p>
<h3 id="树与节点的基本表示"><a href="#树与节点的基本表示" class="headerlink" title="树与节点的基本表示"></a>树与节点的基本表示</h3><p>对于树，最重要的是表现出其节点。通过存储根节点，我们就实际上存储了树    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    Object element ; </span><br><span class="line">    TreeNode firstChild ; </span><br><span class="line">    TreeNode nextSibling; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用以下代码来表示树和节点(MIEC版，更详细):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="keyword">private</span> Node leftChild, rightChild;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(K key, V value)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">max</span><span class="params">( )</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">min</span><span class="params">( )</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">successor</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">predecessor</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderWalk</span><span class="params">( )</span> &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 Binary Tree"></a>二叉树 Binary Tree</h2><p>代码实现部分见“二叉树及相关功能实现”</p>
<p>二叉树是在有限的节点集上定义的结构，这些节点集要么不包含节点，要么由三个不相交的节点集组成：<strong>根节点</strong>、称为<strong>左子树</strong>的二叉树和称为<strong>右子树</strong>的二叉树  </p>
<p><img src="https://s2.loli.net/2022/03/11/sbgGuMalFKvInNS.png"> </p>
<h3 id="Positional-Trees-and-k-ary-Tree"><a href="#Positional-Trees-and-k-ary-Tree" class="headerlink" title="Positional Trees and k-ary Tree"></a>Positional Trees and k-ary Tree</h3><p><img src="https://s2.loli.net/2022/03/11/XtNR5qC9uTyU2B4.png"> </p>
<p>k-ary Tree 中的内节点(即不是叶节点的节点)数量<br><img src="https://s2.loli.net/2022/03/11/GIoHN3qiS5fsnpw.png"> </p>
<h3 id="二叉搜索树-Binary-Search-tree-BST"><a href="#二叉搜索树-Binary-Search-tree-BST" class="headerlink" title="二叉搜索树 Binary Search tree BST"></a>二叉搜索树 Binary Search tree BST</h3><p>二叉搜索树（BST）是一种二叉树，其中每个节点都有一个可比较的键（和一个关联值），并满足以下限制：<strong>任何节点中的键大于该节点左子树中所有节点中的键，小于该节点右子树中所有节点中的键</strong>     </p>
<blockquote>
<p>或者说，对于某个节点对应的值而言，这个值总是大于其左边的值而小于其右边的值    </p>
</blockquote>
<p>“A binary search tree (BST) is a binary  tree where each node has a  Comparable key (and an associated  value) and satisfies the restriction  that the key in any node is larger  than the keys in all nodes in that  node’s left subtree and smaller than  the keys in all nodes in that node’s  right subtree.”</p>
<p><img src="https://s2.loli.net/2022/03/11/CQdGwgnFRELBzi8.png">     </p>
<h3 id="树的遍历-基本介绍"><a href="#树的遍历-基本介绍" class="headerlink" title="树的遍历(基本介绍)"></a>树的遍历(基本介绍)</h3><p>这里基本提一下树的三种遍历方式，详细的代码实现和介绍，于本文《细说树的遍历》一部分  </p>
<p>我们前面说过，我们的树自然是使用递归来生成&#x2F;操作的，自然，想要遍历一棵树，最先想到的也是利用<strong>递归</strong>。根据目的和实现，我们最常使用三种遍历：先序遍历、中序遍历、后序遍历 </p>
<p>先序遍历：先处理当前节点，再处理两棵子树<br>中序遍历：依次序列出各项，处理左子树、当前节点、右子树<br>后序遍历：先处理两棵子树，再处理当前节点</p>
<h4 id="BST-In-Order"><a href="#BST-In-Order" class="headerlink" title="BST:In-Order"></a>BST:In-Order</h4><p>按照<strong>Left-&gt;Root-&gt;Right</strong>的顺序输出结果<br><img src="https://s2.loli.net/2022/03/11/8PTg3BVQnwcG5Ju.png"></p>
<p>我们可以利用递归来实现这种搜索，核心的伪代码如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inOrderWalk(currentRoot)&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentRoot == NIL) &#123;</span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">        <span class="comment">//如果到了一个NIL结点，则代表已经搜索到底了</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//否则继续执行搜索操作  </span></span><br><span class="line">        inOrderWalk(currentRoot.leftChild);</span><br><span class="line">        print(currentRoot.key) ;</span><br><span class="line">        inOrderWalk(currentRoot.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心部分在于<code>else</code>部分，我们逐步分解:   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```print currentRoot.key ;```：在完成一次深度搜索之后，会是前一句```inOrderWalk(currentRoot.leftChild);```的后一句，则可以实现打印，此时打印的结果自然就是刚刚第一个完成搜索得到的点 </span><br><span class="line"></span><br><span class="line">```inOrderWalk(currentRoot.rightChild);```:同理。在完成一次左向搜索后，进行右向搜索，然后自然又会进入到一波递归中去 </span><br><span class="line">![](https://s2.loli.net/2022/03/11/mauNDFQ9djhwiqo.png) </span><br><span class="line"></span><br><span class="line">我们同样还可以使用迭代来完成这种搜索，如下：</span><br><span class="line">```Java</span><br><span class="line">inOrderWalk(currentRoot)&#123;</span><br><span class="line">    S = ∅</span><br><span class="line">    while S ≠ ∅ or currentRoot ≠ NIL&#123;</span><br><span class="line">        if currentRoot ≠ NIL&#123;</span><br><span class="line">            //如果还没找到NIL，就是还未触底，就一直向左找并压入栈</span><br><span class="line">            PUSH(S, currentRoot)</span><br><span class="line">            currentRoot = currentRoot.leftChild</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //触底后进行一次弹出，并且打印，然后开始向右搜索</span><br><span class="line">            currentRoot = POP(S)</span><br><span class="line">            print currentRoot.key</span><br><span class="line">            currentRoot = currentRoot.rightChild</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以想象：在首次压栈的过程中，我们不断加入了最左边的一排结点，触底后，我们开始出栈并打印值，此时实际上是<strong>从下到上</strong>再次进行了一次搜索，不过这次的目的是打印值与向右搜索。如此反复，则可以得到结果。<br>核心原理和递归的做法是一样的</p>
<h4 id="BST：Pre-order"><a href="#BST：Pre-order" class="headerlink" title="BST：Pre-order"></a>BST：Pre-order</h4><p>同样有两种搜索法,思想和做法同上，只是打印顺序不同:<br><img src="https://s2.loli.net/2022/03/11/BRcQqOzvd8sjDlM.png"></p>
<h4 id="BST-Post-order"><a href="#BST-Post-order" class="headerlink" title="BST:Post-order"></a>BST:Post-order</h4><p>同样有两种搜索法,思想和做法同上，只是打印顺序不同:<br><img src="https://s2.loli.net/2022/03/11/9NYKJGeBSuw1ARM.png"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>对于上述的三种搜索法，我们可以归纳为:<br>递归:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Methond(当前节点)&#123;</span><br><span class="line">    若为空返回  </span><br><span class="line"></span><br><span class="line">    若不为空，则&#123;</span><br><span class="line">        A.打印当前</span><br><span class="line">        B.左搜索</span><br><span class="line">        C.右搜索</span><br><span class="line"></span><br><span class="line">        上述ABC按要求排序，如对于in-Order，则是BAC(左，当前，右)</span><br><span class="line">        对于pre-order则是 ABC(当前，左，右)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代：<br>迭代都是利用栈进行，因此和递归法大同小异:   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Methon(当前节点)&#123;</span><br><span class="line">    如果不为空&#123;</span><br><span class="line">        压入</span><br><span class="line">        按需搜索</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    如果为空&#123;</span><br><span class="line">        出栈</span><br><span class="line">        打印</span><br><span class="line">        按需搜索</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里和递归相比，各模式的实现的差别较大，建议分别阅读  </p>
<h4 id="Level-order-Traversal"><a href="#Level-order-Traversal" class="headerlink" title="Level-order Traversal"></a>Level-order Traversal</h4><p>如果依照层次(即深度)来完成搜索，则要利用到队列  </p>
<blockquote>
<p>Level-order按水平顺序，从上到下打印   </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">levelOrderWalk (currentRoot)&#123;</span><br><span class="line">    Q = ∅</span><br><span class="line">    ENQUEUE(Q, currentRoot)</span><br><span class="line">    //首先另队列为空，然后让该节点入队</span><br><span class="line">    while Q ≠ ∅&#123;</span><br><span class="line">        //如果队列不是空的，按下执行操作</span><br><span class="line">        currentNode = DEQUEUE(Q)    </span><br><span class="line">        print currentNode.key   </span><br><span class="line">        //首先让当前节点出队，并打印</span><br><span class="line"></span><br><span class="line">        //然后按照左右节点的情况分别让对应的节点入队</span><br><span class="line">        //这里我们按照先左后右的顺序，以此达到了水平顺序遍历的目的  </span><br><span class="line">        if currentNode.leftChild ≠ NIL </span><br><span class="line">            ENQUEUE(Q, currentNode.leftChild )</span><br><span class="line">        if currentNode.rightChild ≠ NIL </span><br><span class="line">            ENQUEUE(Q, currentNode.rightChild )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树及相关功能实现（源于书本）"><a href="#二叉树及相关功能实现（源于书本）" class="headerlink" title="二叉树及相关功能实现（源于书本）"></a>二叉树及相关功能实现（源于书本）</h2><h3 id="基础与节点定义"><a href="#基础与节点定义" class="headerlink" title="基础与节点定义"></a>基础与节点定义</h3><p>同最基本的树的节点，但我们根据二叉树的性质定义了专门的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryNode</span>&#123;</span><br><span class="line">    Object element ; </span><br><span class="line">    BinaryNode left ; <span class="comment">//左子树</span></span><br><span class="line">    BinaryNode right ; <span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用泛型，做出更普遍性的定义:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BinaryNode</span>&#123;</span><br><span class="line">    AnyType element ; </span><br><span class="line">    BinaryNode&lt;AnyType&gt; left ; </span><br><span class="line">    BinaryNode&lt;AnyType&gt; right ; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造</span></span><br><span class="line">    BinaryNode(AnyType theElement)&#123;</span><br><span class="line">        <span class="built_in">this</span>(theElement,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinaryNode(AnyType theElement ,BinaryNode&lt;AnyType&gt; lt , BinaryNode&lt;AnyType&gt; rt )&#123;</span><br><span class="line">        element = theElement ; </span><br><span class="line">        left = lt ; </span><br><span class="line">        right = rt ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续都会以泛型版本的来写方法，主要使用<code>compareTo</code>方法，而且开销也会来源于此。这些是后话了</p>
<h3 id="二叉树的基本方法"><a href="#二叉树的基本方法" class="headerlink" title="二叉树的基本方法"></a>二叉树的基本方法</h3><h3 id="插入方法insert"><a href="#插入方法insert" class="headerlink" title="插入方法insert"></a>插入方法insert</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title function_">insert</span> <span class="params">(AnyType x , BinaryNode&lt;AnyType&gt; t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BinaryNode</span>&lt;&gt;(x , <span class="literal">null</span> , <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> x.compareTo(t.element)</span><br><span class="line">        <span class="comment">//依据对比结果进行插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//小于，尝试往左边插值</span></span><br><span class="line">        t.left = insert(x,t.left);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.right = insert(x,t.right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//这里不讨论相等的情况，重复元素处理/更新之后再说</span></span><br><span class="line">        <span class="comment">//找到相同的，一般有两种策略，“更新”，或者“同时存储二者”    </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否有某个值-contains"><a href="#是否有某个值-contains" class="headerlink" title="是否有某个值:contains"></a>是否有某个值:contains</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    X是我们要查找的item， t是传入搜索的node，一般最开始的root，后面是递归时的对应点</span></span><br><span class="line"><span class="comment">    若找到了才返回true,否则返回false    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(AnyType x , BinaryNode&lt;AnyType&gt; t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">//如果寻找的点空掉了，那肯定就没有了</span></span><br><span class="line">        <span class="comment">//而且，也是一个baseCase</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> x.compareTo(t.element) ; </span><br><span class="line">    <span class="comment">//调用compareTo方法来进行比较</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(compareResult &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(x,t.left) ; </span><br><span class="line">        <span class="comment">//小于0代表着x的数值小于参数（即t.item）,那么我们向左递归继续找</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//大于0同理</span></span><br><span class="line">        <span class="keyword">return</span> contains(x,t.right) ; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//=0,相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最值查找findMin-x2F-findMax"><a href="#最值查找findMin-x2F-findMax" class="headerlink" title="最值查找findMin&#x2F;findMax"></a>最值查找findMin&#x2F;findMax</h3><p>其二，我们需要知道如何得到最值，事实上这些内容都大同小异：<br>包含两种方法递归和非递归实现,以左树为递归例子，右树为非递归例子<br>在树中的查找，实际上<strong>是不比较值的，找小的就一直往左到底部，找大的同理</strong><br>因为值的比较，实际上是在生成树的时候就进行的了  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//%递归查找(Min)</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title function_">findMin</span><span class="params">(BinaryNode&lt;AnyType&gt;)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.left == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//没有更左边的点了，那这一个点显然就是我们找到的最小值</span></span><br><span class="line">        <span class="keyword">return</span> t ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t.findMin(t.left) ; <span class="comment">//如果没有发生上文的情况，就意味着我们要继续向左搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//%非递归查找(Max)</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title function_">findMax</span><span class="params">(BinaryNode&lt;AnyType&gt;)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            t = t.right ;</span><br><span class="line">            <span class="comment">//t不为空，t的右侧不为空，那么显然就更新t，然后继续右行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树的基础实现"><a href="#二叉查找树的基础实现" class="headerlink" title="二叉查找树的基础实现"></a>二叉查找树的基础实现</h3><p><img src="https://s2.loli.net/2022/04/19/KmcDrg2NfXiwnOG.png"> </p>
<h3 id="删除方法remove"><a href="#删除方法remove" class="headerlink" title="删除方法remove"></a>删除方法remove</h3><p>删除反而是普通二叉树中最麻烦的事情，因此单独拿出来说<br>一般认为有惰性删除与完全删除<br>惰性删除：把要去除的元素标记为，但是实质并没有把它从树中移除，这种方法除了偷懒之外还有益处，具体为：<br><img src="https://s2.loli.net/2022/04/19/i4d9DqGwXSRBbzy.png"> </p>
<p>二是完全删除，这个方法就是改变了节点之间的连接方式，彻底将元素移出树<br>理论操作如下，节选自书：<br><img src="https://s2.loli.net/2022/04/19/5BcXv3sdqtYKlb1.png"><br><img src="https://s2.loli.net/2022/04/19/eQXVxCUfMy8KnPW.png"><br>其代码实现如下：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值是子树的新根,x是我们要删除的部分</span></span><br><span class="line"><span class="comment">//实际上包括两个部分，一个是找x,一个是删除x并更新</span></span><br><span class="line"><span class="keyword">private</span> BinaryNodes&lt;AnyType&gt; <span class="title function_">remove</span><span class="params">(AnyType x,BinaryNode&lt;AnyType&gt; t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> t ; </span><br><span class="line">        <span class="comment">//没有这个值就啥都不做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> x.compareTo(t.element) ;</span><br><span class="line">    <span class="keyword">if</span>(compareResult &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.left = remove(x,t.left);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.right = remove(x,t.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//% 上述的两个情况，实际上是在递归中查找我们要删掉的那个值</span></span><br><span class="line">        <span class="comment">//% 当我们找到了这个值，递归才会进入下面的情况</span></span><br><span class="line">        <span class="comment">//% 在下面的情况中，分为删除节点有两个节点、没有节点、有一个节点的情况</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right !=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//% 此时我们已经找到了那个要删掉的节点了</span></span><br><span class="line">        <span class="comment">//两个子树的情况</span></span><br><span class="line">        t.element = findMin(t.right).element ; <span class="comment">//% 寻找右子树的最小值，让它替代被删除的节点（值代替）  </span></span><br><span class="line">        t.right = remove(t.element,t.right) ; <span class="comment">//% 断开t该位置和原本位置的链接即可</span></span><br><span class="line">        <span class="comment">//@ 这部分内容可能比较抽象，可以结合p83的图4-24理解</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//剩下的情况就简单了，这个其实才是实质上每次递归最后到达的地方</span></span><br><span class="line">        t = (t.left != <span class="literal">null</span>) ? t.left:t.right ; </span><br><span class="line">        <span class="comment">//若左树不为空，则让该位置变为左树根节点</span></span><br><span class="line">        <span class="comment">//实际就是以“让左树根节点代替删除节点”的方法，一次性完成了删除和更新</span></span><br><span class="line">        <span class="comment">//右树同理。如果没有左树我们就选右树了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平均情况的算法分析"><a href="#平均情况的算法分析" class="headerlink" title="平均情况的算法分析"></a>平均情况的算法分析</h3><p>这部分暂略，表达式的求解在快速排序部分有提及。这里引用书本内容：<br><img src="https://s2.loli.net/2022/04/19/YmbaFxzCNu9vDT7.png"><br><img src="https://s2.loli.net/2022/04/19/plq8fGHuwboQtFA.png"><br><img src="https://s2.loli.net/2022/04/19/tIL8NilVb7zWTpu.png"></p>
<h2 id="二叉树及相关功能实现（源于MIEC）"><a href="#二叉树及相关功能实现（源于MIEC）" class="headerlink" title="二叉树及相关功能实现（源于MIEC）"></a>二叉树及相关功能实现（源于MIEC）</h2><p>源于课件伪代码进行的实现，建议看源于书本的部分，更详细且更易懂</p>
<h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><p>在二叉树中，按照其规则，最小值位于最左侧，而最大值位于最右侧，这使得我们可以之间向左&#x2F;向右 搜索来得到最值    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findMin(currentRoot)</span><br><span class="line">    while currentRoot.left ≠ NIL</span><br><span class="line">        currentRoot = currentRoot.leftChild</span><br><span class="line">    return currentRoot</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findMax(currentRoot)</span><br><span class="line">    while currentRoot.rightChild ≠ NIL</span><br><span class="line">        currentRoot = currentRoot.rightChild</span><br><span class="line">    return currentRoot</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Insert(currentRoot,node)&#123;</span><br><span class="line">    //接受根以及一个节点作为参数</span><br><span class="line">    if currentRoot == NIL &#123;</span><br><span class="line">        return node ;</span><br><span class="line">        //如果根节点为空，理所当然，我们返回node</span><br><span class="line">        //实质上的意思就是把它作为根节点    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //下面是根节点非空的情况，我们按照大小顺序来进行位置的插入</span><br><span class="line"></span><br><span class="line">    if node.key &lt; currentRoot.key&#123;</span><br><span class="line">        currentRoot.leftChild = insert(currentRoot.leftChild, node);</span><br><span class="line">        //如果node的值比根小，就以根的左值为子树的根，再次向下搜索</span><br><span class="line">        //这里实际上是用了递归  </span><br><span class="line"></span><br><span class="line">    else if(node.key &lt; currentRoot.key)&#123;</span><br><span class="line">        //同理，大于则向右  </span><br><span class="line">        currentRoot.rightChild = insert(currentRoot.leftChild,node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line">        currentRoot.value = node.value ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return currentRoot ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>首先我们可以分析三种最基础的情况<br><img src="https://s2.loli.net/2022/03/14/B5TSAfeUjOxiZb9.png"><br>分别是对应：本来就是叶节点，没有左&#x2F;右 子树的情况<br>对应的解法分别是：直接移除该节点，以及移除该节点后将其右&#x2F;左子树更新到它之前的位置   </p>
<p>而当要删除的节点的子树情况比较复杂的时候，我们就需要分别考虑并且更新子节点状态<br><img src="https://s2.loli.net/2022/03/14/GmOn9xE7w3FJpgQ.png"> </p>
<p>那么，怎么挑选继承被删除位置node x的点？则继承的点应该是子树中<strong>最小</strong>的点，同时也应该是<strong>大于x.key</strong>的点   </p>
<p>依上分析，我们的代码如下:<br>我们利用递归来解决该问题：因为实际上，base case和每一步的操作是比较明了的<br><img src="https://s2.loli.net/2022/03/14/KDaVpWjH1STZ6Md.png"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(currentRoot,key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentRoot == NIL)&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRoot ; </span><br><span class="line">        <span class="comment">//BaseCase:当输入的结果为空时，则返回该节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下移到要删除的点</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; currentRoot)&#123;</span><br><span class="line">        currentRoot.leftChild = delete(currentRoot.leftChild,key) ; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; currentRoot)&#123;</span><br><span class="line">        currentRoot.rightChild = delete(currentRoot.rightChild,key) ; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(currentRoot.leftChild != NIL &amp;&amp; currentRoot.rightChild != NIL)&#123;</span><br><span class="line">        currentRoot.key = findMin(currentRoot.rightChild).key ; </span><br><span class="line">        currentRoot.rightChild = delete(currentRoot.rightChild , currentRoot.key) ; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        current = (currentRoot.leftChild != <span class="literal">null</span>) ? currentRoot.leftChild : currentRoot.rightChild ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentRoot ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">RetenQ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/19/1.0%20%E6%A0%91%EF%BC%9A%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/">http://example.com/2022/04/19/1.0%20%E6%A0%91%EF%BC%9A%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">RetenQ的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/">MIEC生存手册</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/19/1.1%20%E6%A0%91%EF%BC%9AAVL%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%8C%E9%AB%98%E7%BA%A7%E6%A0%91%E7%AE%80%E4%BB%8B/"><img class="prev-cover" src="https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg" onerror="onerror=null;src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1.1 树：AVL的实现与分析，高级树简介</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/19/2.1.0%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"><img class="next-cover" src="https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg" onerror="onerror=null;src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2.1.0 排序算法：快速排序的实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/19/1.1%20%E6%A0%91%EF%BC%9AAVL%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%8C%E9%AB%98%E7%BA%A7%E6%A0%91%E7%AE%80%E4%BB%8B/" title="1.1 树：AVL的实现与分析，高级树简介"><img class="cover" src="https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-19</div><div class="title">1.1 树：AVL的实现与分析，高级树简介</div></div></a></div><div><a href="/2022/04/19/2.0%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" title="2.0 排序算法：归并排序"><img class="cover" src="https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-19</div><div class="title">2.0 排序算法：归并排序</div></div></a></div><div><a href="/2022/04/19/2.1.0%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="2.1.0 排序算法：快速排序的实现"><img class="cover" src="https://s2.loli.net/2022/04/19/7PoksHucray2wf1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-19</div><div class="title">2.1.0 排序算法：快速排序的实现</div></div></a></div><div><a href="/2022/01/28/1.%E5%8F%8C%E6%8C%87%E9%92%88/" title="【算法】双指针与典型例题"><img class="cover" src="https://s3.bmp.ovh/imgs/2022/01/17305abebdcff48f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-28</div><div class="title">【算法】双指针与典型例题</div></div></a></div><div><a href="/2022/01/28/2.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="【算法】二分查找与典型例题"><img class="cover" src="https://s3.bmp.ovh/imgs/2022/01/17305abebdcff48f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-28</div><div class="title">【算法】二分查找与典型例题</div></div></a></div><div><a href="/2022/01/28/3.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="【算法】滑动窗口及其例题"><img class="cover" src="https://s3.bmp.ovh/imgs/2022/01/17305abebdcff48f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-28</div><div class="title">【算法】滑动窗口及其例题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/08/12/AzsRr7yUNo5Ibhg.png" onerror="this.onerror=null;this.src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="avatar"/></div><div class="author-info__name">RetenQ</div><div class="author-info__description">于是百无聊赖中写下了答案的最后一笔</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RetenQ"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com//RetenQ" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://twitter.com/RetenQ" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a><a class="social-icon" href="mailto:RetenQ@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">你好！这里是某csse菜鸡的博客，有需要的话欢迎通过QQ或者Email联系我！ 3452567280 RetenQ@outlook.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%96%87"><span class="toc-number">1.1.</span> <span class="toc-text">前文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">树的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E8%8A%82%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">树与节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">树与节点的基本表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree"><span class="toc-number">1.4.</span> <span class="toc-text">二叉树 Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Positional-Trees-and-k-ary-Tree"><span class="toc-number">1.4.1.</span> <span class="toc-text">Positional Trees and k-ary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-Binary-Search-tree-BST"><span class="toc-number">1.4.2.</span> <span class="toc-text">二叉搜索树 Binary Search tree BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.3.</span> <span class="toc-text">树的遍历(基本介绍)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BST-In-Order"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">BST:In-Order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BST%EF%BC%9APre-order"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">BST：Pre-order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BST-Post-order"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">BST:Post-order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Level-order-Traversal"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">Level-order Traversal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%BA%90%E4%BA%8E%E4%B9%A6%E6%9C%AC%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">二叉树及相关功能实现（源于书本）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">基础与节点定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">二叉树的基本方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95insert"><span class="toc-number">1.5.3.</span> <span class="toc-text">插入方法insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E4%B8%AA%E5%80%BC-contains"><span class="toc-number">1.5.4.</span> <span class="toc-text">是否有某个值:contains</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%80%BC%E6%9F%A5%E6%89%BEfindMin-x2F-findMax"><span class="toc-number">1.5.5.</span> <span class="toc-text">最值查找findMin&#x2F;findMax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.6.</span> <span class="toc-text">二叉查找树的基础实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95remove"><span class="toc-number">1.5.7.</span> <span class="toc-text">删除方法remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.5.8.</span> <span class="toc-text">平均情况的算法分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%BA%90%E4%BA%8EMIEC%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">二叉树及相关功能实现（源于MIEC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%80%BC"><span class="toc-number">1.6.1.</span> <span class="toc-text">最值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.3.</span> <span class="toc-text">删除</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/MIEC%E5%AD%A6%E7%94%9F%E5%BA%94%E4%BC%9A%E7%94%A8/" title="MIEC学生新手手册"><img src="https://s2.loli.net/2022/01/12/iuhM7UpVqBzPT3t.jpg" onerror="this.onerror=null;this.src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="MIEC学生新手手册"/></a><div class="content"><a class="title" href="/2022/08/15/MIEC%E5%AD%A6%E7%94%9F%E5%BA%94%E4%BC%9A%E7%94%A8/" title="MIEC学生新手手册">MIEC学生新手手册</a><time datetime="2022-08-15T08:56:33.000Z" title="发表于 2022-08-15 16:56:33">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/MissingSemester(2)VIM%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" title="MissingSemester(2)VIM基础操作"><img src="https://s2.loli.net/2022/08/15/YneZqjNl2MbSymc.jpg" onerror="this.onerror=null;this.src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="MissingSemester(2)VIM基础操作"/></a><div class="content"><a class="title" href="/2022/08/15/MissingSemester(2)VIM%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" title="MissingSemester(2)VIM基础操作">MissingSemester(2)VIM基础操作</a><time datetime="2022-08-15T04:01:33.000Z" title="发表于 2022-08-15 12:01:33">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/MissingSemester(3)%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86/" title="MissingSemester(3)正则表达式与数据整理"><img src="https://s2.loli.net/2022/08/15/YneZqjNl2MbSymc.jpg" onerror="this.onerror=null;this.src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="MissingSemester(3)正则表达式与数据整理"/></a><div class="content"><a class="title" href="/2022/08/15/MissingSemester(3)%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86/" title="MissingSemester(3)正则表达式与数据整理">MissingSemester(3)正则表达式与数据整理</a><time datetime="2022-08-15T04:01:33.000Z" title="发表于 2022-08-15 12:01:33">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/MissingSemester(1)%E5%88%9D%E8%AF%86Shell%E4%BB%A5%E5%8F%8ABash/" title="MissingSemester(1):初识Shell以及Bash"><img src="https://s2.loli.net/2022/08/15/YneZqjNl2MbSymc.jpg" onerror="this.onerror=null;this.src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="MissingSemester(1):初识Shell以及Bash"/></a><div class="content"><a class="title" href="/2022/08/15/MissingSemester(1)%E5%88%9D%E8%AF%86Shell%E4%BB%A5%E5%8F%8ABash/" title="MissingSemester(1):初识Shell以及Bash">MissingSemester(1):初识Shell以及Bash</a><time datetime="2022-08-15T03:01:33.000Z" title="发表于 2022-08-15 11:01:33">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/12/hello-world/" title="Hello World"><img src="https://s3.bmp.ovh/imgs/2022/01/17305abebdcff48f.jpg" onerror="this.onerror=null;this.src='https://s2.loli.net/2022/01/13/lsqSbINmozkPFpM.png'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/08/12/hello-world/" title="Hello World">Hello World</a><time datetime="2022-08-12T08:23:28.877Z" title="发表于 2022-08-12 16:23:28">2022-08-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By RetenQ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>