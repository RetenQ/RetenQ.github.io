<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RetenQ的博客</title>
  
  <subtitle>各种CSSE相关</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-12T07:49:44.096Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>RetenQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/12/hello-world/"/>
    <id>http://example.com/2022/08/12/hello-world/</id>
    <published>2022-08-12T08:23:28.877Z</published>
    <updated>2022-08-12T07:49:44.096Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1.1 树：AVL的实现与分析，高级树简介</title>
    <link href="http://example.com/2022/04/19/1.1%20%E6%A0%91%EF%BC%9AAVL%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%8C%E9%AB%98%E7%BA%A7%E6%A0%91%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2022/04/19/1.1%20%E6%A0%91%EF%BC%9AAVL%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%8C%E9%AB%98%E7%BA%A7%E6%A0%91%E7%AE%80%E4%BB%8B/</id>
    <published>2022-04-19T12:27:00.000Z</published>
    <updated>2022-08-12T07:31:25.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2><p>AVL（Adelson-Velsky and Landis）树是一种自平衡二叉搜索树<br>对于树中的每一个节点，左、右子树的高度最多只能相差1  </p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>搜索树上的大多数原始操作在O(h)时间内在高度为h树上运行,树的高度在一棵AVL树中，是O(lgN)   </p><p>一棵AVL树是左右子树高度最大相差1的树(其中空树的高度定义为-1)<br>在高度为h的AVL树中，最少节点数S(h) &#x3D; S(h-1) + S(h-2) + 1 ;h&#x3D;0,S(h)&#x3D;1;h&#x3D;1,S(h)&#x3D;2 </p><h3 id="AVL的平衡，旋转"><a href="#AVL的平衡，旋转" class="headerlink" title="AVL的平衡，旋转"></a>AVL的平衡，旋转</h3><p>AVL是特殊化的二叉树，想要保证AVL的平衡，我们可以用到一种称为平衡的做法。<strong>是否进行平衡</strong>的问题由树之间的高度决定    </p><h4 id="AVL的基础定义与高度计算"><a href="#AVL的基础定义与高度计算" class="headerlink" title="AVL的基础定义与高度计算"></a>AVL的基础定义与高度计算</h4><p>这里先给出AVL的基本定义以及高度计算 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//%AVL定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AvlNode</span>&lt;AnyType&gt;</span><br><span class="line">&#123;</span><br><span class="line">    AnyType elemenet ; </span><br><span class="line">    AvlNode&lt;AnyType&gt; left ; </span><br><span class="line">    AvlNode&lt;AnyType&gt; right ; </span><br><span class="line">    <span class="type">int</span> height ;</span><br><span class="line"></span><br><span class="line">    AvlNode(AnyType theElement)&#123;</span><br><span class="line">        <span class="built_in">this</span>(theElement,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AvlNode(AnyType theElement , AvlNode&lt;AnyType&gt; lt , AvlNode&lt;AnyType&gt; rt)&#123;</span><br><span class="line">        elemenet = theElement ; </span><br><span class="line">        left = lt ; </span><br><span class="line">        right = rt ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高度计算:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//%AVL高度计算</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">theHeight</span><span class="params">(AvlNode&lt;AnyType&gt; t)</span>&#123;</span><br><span class="line">    <span class="comment">//返回高度，若满则-1</span></span><br><span class="line">    <span class="keyword">return</span> t == <span class="literal">null</span> ? -<span class="number">1</span>:t.height ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>实质上，我们设这里有a这个节点，在插入后只有以下四种情况：<br>1.对a左儿子的左子树进行插入(左、左，同向)<br>2.对a左儿子的右子树进行插入(左、右，异向)<br>3.对a右儿子的右子树进行插入(右、右，同向)<br>4.对a右儿子的左子树进行插入(右、左，异向)   </p><p>具体理论和原理比较长，见书P86-P91,总之：<br><strong>同向的情况用单旋转，异向的情况用双旋转</strong><br>代码实现如下：  </p><h5 id="单旋转平衡-代码实现"><a href="#单旋转平衡-代码实现" class="headerlink" title="单旋转平衡(代码实现)"></a>单旋转平衡(代码实现)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//% 单旋转</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateWithLeftChild</span><span class="params">(AvlNode&lt;AnyType&gt; k2)</span>&#123;</span><br><span class="line">    AvlNode&lt;AnyType&gt; k1 = k2.left ; </span><br><span class="line">    k2.left = k1.right ;</span><br><span class="line">    k1.right = k2 ; </span><br><span class="line"></span><br><span class="line">    k2.height = Math.max(height(k2.left), height(k2.right)) + <span class="number">1</span> ;</span><br><span class="line">    k1.height = Math.max(height(k1.left), k2.height) + <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k1 ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title function_">rotateWithRightChild</span><span class="params">(AvlNode&lt;AnyType&gt; k2)</span>&#123;</span><br><span class="line">    AvlNode&lt;AnyType&gt; k1 = k2.right ; </span><br><span class="line">    k2.right = k1.left ; </span><br><span class="line">    k1.left = k2 ; </span><br><span class="line"></span><br><span class="line">    k2.height = Math.max(height(k2.left), height(k2.right)) + <span class="number">1</span> ;</span><br><span class="line">    k1.height = Math.max(height(k1.right),k2.height) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> k1 ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双旋转平衡-代码实现"><a href="#双旋转平衡-代码实现" class="headerlink" title="双旋转平衡(代码实现)"></a>双旋转平衡(代码实现)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//% 双旋转</span></span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title function_">doubleWithLeftChild</span><span class="params">(AvlNode&lt;AnyType&gt; k3)</span>&#123;</span><br><span class="line">    k3.left = rotateWithRightChild(k3.left) ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotateWithLeftChild(k3) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title function_">doubleWithRightChild</span><span class="params">(AvlNode&lt;AnyType&gt; k3)</span>&#123;</span><br><span class="line">    k3.left = rotateWithLeftChild(k3.left) ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotateWithRightChild(k3) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL的插入和平衡"><a href="#AVL的插入和平衡" class="headerlink" title="AVL的插入和平衡"></a>AVL的插入和平衡</h3><p>AVL的核心就在于<strong>在插入之后会进行一次对树的平衡</strong>，具体做法已经在上一部分说过了，这里直接给出对应代码   </p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//% 插入</span></span><br><span class="line"><span class="keyword">public</span> AvlNode&lt;AnyType&gt; <span class="title function_">insert</span> <span class="params">(AnyType x , AvlNode&lt;AnyType&gt; t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AvlNode</span>&lt;&gt;(x,<span class="literal">null</span>,<span class="literal">null</span>) ; </span><br><span class="line">        <span class="comment">//没有root的话，插入的第一个就是root</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找位置，下面部分同正常的二叉树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> x.compareTo(t.elemenet) ; </span><br><span class="line">    <span class="keyword">if</span>(compareResult &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.left = insert(x,t.left);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.right = insert(x,t.right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blance(t) ; <span class="comment">//返回的值是要重新平衡之后的树，平衡的方法见下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//% 平衡</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ALLOWED_IMBAKANCE</span> <span class="operator">=</span> <span class="number">1</span> ; <span class="comment">//平衡高度差，就是1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title function_">balance</span><span class="params">(AvlNode&lt;AnyType&gt; t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> t ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面根据情况判断做单旋转还是双旋转，旋转的方法在blance方法后写出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(height(t.left) - height(t.right) &gt; ALLOWED_IMBAKANCE)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height(t.left.left) &gt;= height(t.left.right))&#123;</span><br><span class="line">            <span class="comment">//这里的“等于”是为了保证在对称情景（图4-33）的类似情景下，我们使用的是单旋转</span></span><br><span class="line">            t = rotateWithLeftChild(t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t = doubleWithLeftChild(t); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height(t.right)  - height(t.left) &gt; ALLOWED_IMBAKANCE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height(t.right.right) &gt;= height(t.right.left))&#123;</span><br><span class="line">            <span class="comment">//这里的“等于”是为了保证在对称情景（图4-33）的类似情景下，我们使用的是单旋转</span></span><br><span class="line">                t = rotateWithRightChild(t) ; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t = doubleWithRightChild(t) ; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    t.height = Math.max(height(t.left) , height(t.right)) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> t  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL的删除"><a href="#AVL的删除" class="headerlink" title="AVL的删除"></a>AVL的删除</h3><p>同前文，就是把插入改为删除，或者说“在二叉树原方法的基础上，最后加入平衡的步骤”<br>依旧是“寻值-&gt;操作&#x2F;删除-&gt;再平衡-&gt;更新”   </p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//% 删除</span></span><br><span class="line"><span class="comment">//删除与插入是十分类似的</span></span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title function_">remove</span><span class="params">(AnyType x , AvlNode&lt;AnyType&gt; t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ; <span class="comment">//找不到就不进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这部分实质上就是在尝试寻找我们的x</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> x.compareTo(t.elemenet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        t.left = remove(x,t.left) ; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.right = remove(x,t.right) ; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//不大不小，而且不是null，那就是找到了。下面根据情况做删除处理  </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//这里的处理同正常二叉树</span></span><br><span class="line">        t.elemenet = findMin(t.right).elemenet ; </span><br><span class="line">        t.right = remove(t.elemenet , t.right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t = (t.left != <span class="literal">null</span>) ? t.left : t.right ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作结束后平衡该树</span></span><br><span class="line">    <span class="keyword">return</span> balance(t) ; <span class="comment">//返回平衡后的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.在AVL树中，对于树中的每个节点，左右子树的高度最多可以相差一个，即高度平衡。平衡是AVL的核心，毕竟是自平衡树<br>2.要删除的节点可以标记为已删除，因此不需要重新平衡<br>3.在平均情况和最坏情况下，搜索、插入和删除都需要 O(log_2 N) 时间<br>4.在某些情况下，AVL 树可能会偏重，导致性能相对较差  </p><h2 id="高级树简介"><a href="#高级树简介" class="headerlink" title="高级树简介"></a>高级树简介</h2><p>下面写的树多归“高级数据结构”内容了，这里只作简介&#x2F;应试要求   </p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是 AVL 树的替代品，红黑树也是一种自平衡二叉搜索树<br>红背树的操作最坏情况下需要𝑂(lg𝑁)时间，红黑树的高度最多为2lg(𝑁+1)<br>红背树中的每个节点都需要<strong>一个额外的位来存储节点的颜色</strong>，可以是红色或黑色  </p><p>红黑树确保从根到叶的路径<strong>不超过任何其他路径的两倍</strong>，因此树是近似平衡的    </p><h4 id="基本性质与基本介绍"><a href="#基本性质与基本介绍" class="headerlink" title="基本性质与基本介绍"></a>基本性质与基本介绍</h4><p>1.每个节点都是红色或黑色<br>2.根root是黑色的<br>3.如果一个节点是红色的，它的两个子节点都将被涂成黑色<br>4.对于每个节点，从节点到后代叶子的<strong>所有简单路径都包含相同数量的黑色节点</strong>  </p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入的基本规则是：<br>1.只能定为红或黑，其中<strong>根和null节点必须是黑</strong><br>2.红节点的子节点必须是黑节点（这条结合步骤理解）<br>3.相同数量的黑色节点  </p><p>步骤：<br>1.按照二叉搜索树中使用的插入规则插入节点<br>2.将新插入的节点涂成红色<br>3.如果违反规则，则<strong>从上到下修复颜色</strong>  </p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>•红黑树是自平衡二叉搜索树<br>•每个节点需要一个额外的位来存储节点的颜色<br>•节点只能被着色为红色或黑色<br>•红黑树的开销相对较低插入<br>•在实践中，与 AVL 树相比，旋转发生的频率相对较低<br>•使用红黑树可以避免侧超权子树（普通的AVL是很容易发生偏移的）    </p><h3 id="伸展树SplayTrees"><a href="#伸展树SplayTrees" class="headerlink" title="伸展树SplayTrees"></a>伸展树SplayTrees</h3><p>splay树保证从空树开始的任意M个连续树操作最多花费O（MlgN）时间<br>Splay树基于这样一个事实，即BST每次操作的O（N）最坏情况时间<strong>并不坏</strong>，只要它<strong>发生的频率相对较低</strong>,就是说不去把重点放在考虑处理最坏情况上，而是优化最坏情况发生的频率<br>splay树的基本思想是在一个节点被访问后，通过一系列的AVL树旋转将该节点推到根，在展开树中，如果一个节点很深，那么路径上有很多节点也比较深，通过展开我们可以使所有这些节点上的未来访问更快  </p><h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h4><p>1.展开深度为 d 的节点 x 需要 𝜽(𝒅) 时间，即与访问 x 的时间成正比的时间   </p><p>2.展开不仅将 x 移动到根，而且将访问路径上每个节点的深度大致减半 </p><p>插入和删除节点需要 𝑶(𝐥𝐠𝑵) 摊销时间<br>在分析中，节点的电位可以是任意值，但是固定的    </p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>渐近分析假设整个数据结构在计算机的主存中，当数据大小大于主存容量时，部分数据结构必须存储在磁盘上。如果发生这种情况，算法的渐进效率将变得毫无意义，因为磁盘访问比访问存储在内存中的数据慢得多。  </p><p>B-tree 及其变体，如 B+-trees 和 B*-trees，是为了提高树操作的效率而开发的    </p><h4 id="基本性质-1"><a href="#基本性质-1" class="headerlink" title="基本性质"></a>基本性质</h4><p>M 阶 B 树是 M 叉树<br>1.数据项存储在外部节点，每个内部节点最多存储 M-1 个密钥来指导搜索<br>2.密钥以非递减顺序存储<br>3.根要么是叶子，要么有 2 到 M 个子节点<br>4.所有内部节点（根节点除外）都有 M&#x2F;2 和 M 个子节点<br>5.所有外部节点都处于相同深度，并且具有 L&#x2F;2 和 L 之间的数据项    </p><blockquote><p>请注意，B 树有许多变体，每种变体的属性都略有不同。上述属性适用于 B-tree 的一种流行变体，称为 B+-tree  </p></blockquote><p><img src="https://s2.loli.net/2022/04/17/8jImMUOudRrogDC.png"># 这是啥<br>整合了书和MIEC的内容    </p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>同MIEC原笔记</p>]]></content>
    
    
    <summary type="html">进一步加入了AVL的介绍、实现原理、代码实现，以及初步记录了红黑树，展开树，B/B+树。基于《数据结构与算法分析_Java实现》，以及一部分的MIEC课程</summary>
    
    
    
    <category term="MIEC生存手册" scheme="http://example.com/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/"/>
    
    <category term="算法与数据结构" scheme="http://example.com/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="MIEC生存手册" scheme="http://example.com/tags/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>1.0 树：树的简介，二叉树的实现</title>
    <link href="http://example.com/2022/04/19/1.0%20%E6%A0%91%EF%BC%9A%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/04/19/1.0%20%E6%A0%91%EF%BC%9A%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-19T12:08:00.000Z</published>
    <updated>2022-08-12T07:31:19.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树&#x2F;自由树(tree&#x2F;free tree)是一个连通的、非循环的无向图   </p><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>初步阐释了树，以及对于<strong>二叉树、AVL树的实现与分析</strong>。<br>最后简单介绍了红黑树、伸展树、B&#x2F;B+树，如果有需要&#x2F;有机会的话补充这三者的实现与分析(好复杂)   </p><h2 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h2><p>树有多种方式定义，其中一种自然的方式是采用递归<br>一棵树是一些点的集合，这个集合也能是空集；<br>若不为空集，树<strong>就由称作跟root的节点r，以及0到N个的非空(子)树组成，子树的每一棵的跟都有来自r的一条有向边连接</strong><br>在递归定义中，我们认为“一棵树是N个节点和N-1跳边的集合，其中一个节点为根root”    </p><h2 id="树与节点"><a href="#树与节点" class="headerlink" title="树与节点"></a>树与节点</h2><p>根节点：最初的节点，被称为根或根节点 Root&#x2F;Root Node<br>叶&#x2F;外节点:没有子节点的的点 Leaf&#x2F;External Node<br>内节点：非叶节点的其他节点 Internal Node</p><p>深度Depth:从根到节点的简单路径的长度<br>高度Height:一棵树的最大深度，对于任意节点ni,ni的深度到一片树叶的最远路径长<br>Degree 根节点的子节点数目<br><img src="https://s2.loli.net/2022/03/11/hVSWFYcX5wduPBj.png"> </p><p>节点祖先 Ancestor of a node：从根节点到指定节点的唯一简单路径上的任何节点<br>后代 Descendant: 如果A是B的祖先节点，则B是A的后代节点   </p><blockquote><p>每个节点都是自己的Ancestor和Descendant    </p></blockquote><p>父节点 Parent:从根节点到指定节点的简单路径上的最后一条边的那个点，则是指定节点的父节点。根节点是唯一没有父节点的节点 </p><p>同级节点 siblings:如果两个节点拥有相同的父节点，则它们是同级节点    </p><p>子树和子树根节点 :以节点为根的子树是由以节点为根的节点的后代生成的树  </p><p><img src="https://s2.loli.net/2022/03/11/nD4xcLWrpsUZFmz.png"> </p><h3 id="树与节点的基本表示"><a href="#树与节点的基本表示" class="headerlink" title="树与节点的基本表示"></a>树与节点的基本表示</h3><p>对于树，最重要的是表现出其节点。通过存储根节点，我们就实际上存储了树    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    Object element ; </span><br><span class="line">    TreeNode firstChild ; </span><br><span class="line">    TreeNode nextSibling; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用以下代码来表示树和节点(MIEC版，更详细):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="keyword">private</span> Node leftChild, rightChild;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(K key, V value)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">max</span><span class="params">( )</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">min</span><span class="params">( )</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">successor</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">predecessor</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderWalk</span><span class="params">( )</span> &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 Binary Tree"></a>二叉树 Binary Tree</h2><p>代码实现部分见“二叉树及相关功能实现”</p><p>二叉树是在有限的节点集上定义的结构，这些节点集要么不包含节点，要么由三个不相交的节点集组成：<strong>根节点</strong>、称为<strong>左子树</strong>的二叉树和称为<strong>右子树</strong>的二叉树  </p><p><img src="https://s2.loli.net/2022/03/11/sbgGuMalFKvInNS.png"> </p><h3 id="Positional-Trees-and-k-ary-Tree"><a href="#Positional-Trees-and-k-ary-Tree" class="headerlink" title="Positional Trees and k-ary Tree"></a>Positional Trees and k-ary Tree</h3><p><img src="https://s2.loli.net/2022/03/11/XtNR5qC9uTyU2B4.png"> </p><p>k-ary Tree 中的内节点(即不是叶节点的节点)数量<br><img src="https://s2.loli.net/2022/03/11/GIoHN3qiS5fsnpw.png"> </p><h3 id="二叉搜索树-Binary-Search-tree-BST"><a href="#二叉搜索树-Binary-Search-tree-BST" class="headerlink" title="二叉搜索树 Binary Search tree BST"></a>二叉搜索树 Binary Search tree BST</h3><p>二叉搜索树（BST）是一种二叉树，其中每个节点都有一个可比较的键（和一个关联值），并满足以下限制：<strong>任何节点中的键大于该节点左子树中所有节点中的键，小于该节点右子树中所有节点中的键</strong>     </p><blockquote><p>或者说，对于某个节点对应的值而言，这个值总是大于其左边的值而小于其右边的值    </p></blockquote><p>“A binary search tree (BST) is a binary  tree where each node has a  Comparable key (and an associated  value) and satisfies the restriction  that the key in any node is larger  than the keys in all nodes in that  node’s left subtree and smaller than  the keys in all nodes in that node’s  right subtree.”</p><p><img src="https://s2.loli.net/2022/03/11/CQdGwgnFRELBzi8.png">     </p><h3 id="树的遍历-基本介绍"><a href="#树的遍历-基本介绍" class="headerlink" title="树的遍历(基本介绍)"></a>树的遍历(基本介绍)</h3><p>这里基本提一下树的三种遍历方式，详细的代码实现和介绍，于本文《细说树的遍历》一部分  </p><p>我们前面说过，我们的树自然是使用递归来生成&#x2F;操作的，自然，想要遍历一棵树，最先想到的也是利用<strong>递归</strong>。根据目的和实现，我们最常使用三种遍历：先序遍历、中序遍历、后序遍历 </p><p>先序遍历：先处理当前节点，再处理两棵子树<br>中序遍历：依次序列出各项，处理左子树、当前节点、右子树<br>后序遍历：先处理两棵子树，再处理当前节点</p><h4 id="BST-In-Order"><a href="#BST-In-Order" class="headerlink" title="BST:In-Order"></a>BST:In-Order</h4><p>按照<strong>Left-&gt;Root-&gt;Right</strong>的顺序输出结果<br><img src="https://s2.loli.net/2022/03/11/8PTg3BVQnwcG5Ju.png"></p><p>我们可以利用递归来实现这种搜索，核心的伪代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inOrderWalk(currentRoot)&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentRoot == NIL) &#123;</span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">        <span class="comment">//如果到了一个NIL结点，则代表已经搜索到底了</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//否则继续执行搜索操作  </span></span><br><span class="line">        inOrderWalk(currentRoot.leftChild);</span><br><span class="line">        print(currentRoot.key) ;</span><br><span class="line">        inOrderWalk(currentRoot.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心部分在于<code>else</code>部分，我们逐步分解:   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```print currentRoot.key ;```：在完成一次深度搜索之后，会是前一句```inOrderWalk(currentRoot.leftChild);```的后一句，则可以实现打印，此时打印的结果自然就是刚刚第一个完成搜索得到的点 </span><br><span class="line"></span><br><span class="line">```inOrderWalk(currentRoot.rightChild);```:同理。在完成一次左向搜索后，进行右向搜索，然后自然又会进入到一波递归中去 </span><br><span class="line">![](https://s2.loli.net/2022/03/11/mauNDFQ9djhwiqo.png) </span><br><span class="line"></span><br><span class="line">我们同样还可以使用迭代来完成这种搜索，如下：</span><br><span class="line">```Java</span><br><span class="line">inOrderWalk(currentRoot)&#123;</span><br><span class="line">    S = ∅</span><br><span class="line">    while S ≠ ∅ or currentRoot ≠ NIL&#123;</span><br><span class="line">        if currentRoot ≠ NIL&#123;</span><br><span class="line">            //如果还没找到NIL，就是还未触底，就一直向左找并压入栈</span><br><span class="line">            PUSH(S, currentRoot)</span><br><span class="line">            currentRoot = currentRoot.leftChild</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //触底后进行一次弹出，并且打印，然后开始向右搜索</span><br><span class="line">            currentRoot = POP(S)</span><br><span class="line">            print currentRoot.key</span><br><span class="line">            currentRoot = currentRoot.rightChild</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以想象：在首次压栈的过程中，我们不断加入了最左边的一排结点，触底后，我们开始出栈并打印值，此时实际上是<strong>从下到上</strong>再次进行了一次搜索，不过这次的目的是打印值与向右搜索。如此反复，则可以得到结果。<br>核心原理和递归的做法是一样的</p><h4 id="BST：Pre-order"><a href="#BST：Pre-order" class="headerlink" title="BST：Pre-order"></a>BST：Pre-order</h4><p>同样有两种搜索法,思想和做法同上，只是打印顺序不同:<br><img src="https://s2.loli.net/2022/03/11/BRcQqOzvd8sjDlM.png"></p><h4 id="BST-Post-order"><a href="#BST-Post-order" class="headerlink" title="BST:Post-order"></a>BST:Post-order</h4><p>同样有两种搜索法,思想和做法同上，只是打印顺序不同:<br><img src="https://s2.loli.net/2022/03/11/9NYKJGeBSuw1ARM.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>对于上述的三种搜索法，我们可以归纳为:<br>递归:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Methond(当前节点)&#123;</span><br><span class="line">    若为空返回  </span><br><span class="line"></span><br><span class="line">    若不为空，则&#123;</span><br><span class="line">        A.打印当前</span><br><span class="line">        B.左搜索</span><br><span class="line">        C.右搜索</span><br><span class="line"></span><br><span class="line">        上述ABC按要求排序，如对于in-Order，则是BAC(左，当前，右)</span><br><span class="line">        对于pre-order则是 ABC(当前，左，右)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代：<br>迭代都是利用栈进行，因此和递归法大同小异:   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Methon(当前节点)&#123;</span><br><span class="line">    如果不为空&#123;</span><br><span class="line">        压入</span><br><span class="line">        按需搜索</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    如果为空&#123;</span><br><span class="line">        出栈</span><br><span class="line">        打印</span><br><span class="line">        按需搜索</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里和递归相比，各模式的实现的差别较大，建议分别阅读  </p><h4 id="Level-order-Traversal"><a href="#Level-order-Traversal" class="headerlink" title="Level-order Traversal"></a>Level-order Traversal</h4><p>如果依照层次(即深度)来完成搜索，则要利用到队列  </p><blockquote><p>Level-order按水平顺序，从上到下打印   </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">levelOrderWalk (currentRoot)&#123;</span><br><span class="line">    Q = ∅</span><br><span class="line">    ENQUEUE(Q, currentRoot)</span><br><span class="line">    //首先另队列为空，然后让该节点入队</span><br><span class="line">    while Q ≠ ∅&#123;</span><br><span class="line">        //如果队列不是空的，按下执行操作</span><br><span class="line">        currentNode = DEQUEUE(Q)    </span><br><span class="line">        print currentNode.key   </span><br><span class="line">        //首先让当前节点出队，并打印</span><br><span class="line"></span><br><span class="line">        //然后按照左右节点的情况分别让对应的节点入队</span><br><span class="line">        //这里我们按照先左后右的顺序，以此达到了水平顺序遍历的目的  </span><br><span class="line">        if currentNode.leftChild ≠ NIL </span><br><span class="line">            ENQUEUE(Q, currentNode.leftChild )</span><br><span class="line">        if currentNode.rightChild ≠ NIL </span><br><span class="line">            ENQUEUE(Q, currentNode.rightChild )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树及相关功能实现（源于书本）"><a href="#二叉树及相关功能实现（源于书本）" class="headerlink" title="二叉树及相关功能实现（源于书本）"></a>二叉树及相关功能实现（源于书本）</h2><h3 id="基础与节点定义"><a href="#基础与节点定义" class="headerlink" title="基础与节点定义"></a>基础与节点定义</h3><p>同最基本的树的节点，但我们根据二叉树的性质定义了专门的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryNode</span>&#123;</span><br><span class="line">    Object element ; </span><br><span class="line">    BinaryNode left ; <span class="comment">//左子树</span></span><br><span class="line">    BinaryNode right ; <span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用泛型，做出更普遍性的定义:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BinaryNode</span>&#123;</span><br><span class="line">    AnyType element ; </span><br><span class="line">    BinaryNode&lt;AnyType&gt; left ; </span><br><span class="line">    BinaryNode&lt;AnyType&gt; right ; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造</span></span><br><span class="line">    BinaryNode(AnyType theElement)&#123;</span><br><span class="line">        <span class="built_in">this</span>(theElement,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinaryNode(AnyType theElement ,BinaryNode&lt;AnyType&gt; lt , BinaryNode&lt;AnyType&gt; rt )&#123;</span><br><span class="line">        element = theElement ; </span><br><span class="line">        left = lt ; </span><br><span class="line">        right = rt ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续都会以泛型版本的来写方法，主要使用<code>compareTo</code>方法，而且开销也会来源于此。这些是后话了</p><h3 id="二叉树的基本方法"><a href="#二叉树的基本方法" class="headerlink" title="二叉树的基本方法"></a>二叉树的基本方法</h3><h3 id="插入方法insert"><a href="#插入方法insert" class="headerlink" title="插入方法insert"></a>插入方法insert</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title function_">insert</span> <span class="params">(AnyType x , BinaryNode&lt;AnyType&gt; t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BinaryNode</span>&lt;&gt;(x , <span class="literal">null</span> , <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> x.compareTo(t.element)</span><br><span class="line">        <span class="comment">//依据对比结果进行插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//小于，尝试往左边插值</span></span><br><span class="line">        t.left = insert(x,t.left);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.right = insert(x,t.right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//这里不讨论相等的情况，重复元素处理/更新之后再说</span></span><br><span class="line">        <span class="comment">//找到相同的，一般有两种策略，“更新”，或者“同时存储二者”    </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否有某个值-contains"><a href="#是否有某个值-contains" class="headerlink" title="是否有某个值:contains"></a>是否有某个值:contains</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    X是我们要查找的item， t是传入搜索的node，一般最开始的root，后面是递归时的对应点</span></span><br><span class="line"><span class="comment">    若找到了才返回true,否则返回false    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(AnyType x , BinaryNode&lt;AnyType&gt; t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">//如果寻找的点空掉了，那肯定就没有了</span></span><br><span class="line">        <span class="comment">//而且，也是一个baseCase</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> x.compareTo(t.element) ; </span><br><span class="line">    <span class="comment">//调用compareTo方法来进行比较</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(compareResult &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(x,t.left) ; </span><br><span class="line">        <span class="comment">//小于0代表着x的数值小于参数（即t.item）,那么我们向左递归继续找</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//大于0同理</span></span><br><span class="line">        <span class="keyword">return</span> contains(x,t.right) ; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//=0,相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最值查找findMin-x2F-findMax"><a href="#最值查找findMin-x2F-findMax" class="headerlink" title="最值查找findMin&#x2F;findMax"></a>最值查找findMin&#x2F;findMax</h3><p>其二，我们需要知道如何得到最值，事实上这些内容都大同小异：<br>包含两种方法递归和非递归实现,以左树为递归例子，右树为非递归例子<br>在树中的查找，实际上<strong>是不比较值的，找小的就一直往左到底部，找大的同理</strong><br>因为值的比较，实际上是在生成树的时候就进行的了  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//%递归查找(Min)</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title function_">findMin</span><span class="params">(BinaryNode&lt;AnyType&gt;)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.left == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//没有更左边的点了，那这一个点显然就是我们找到的最小值</span></span><br><span class="line">        <span class="keyword">return</span> t ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t.findMin(t.left) ; <span class="comment">//如果没有发生上文的情况，就意味着我们要继续向左搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//%非递归查找(Max)</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title function_">findMax</span><span class="params">(BinaryNode&lt;AnyType&gt;)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            t = t.right ;</span><br><span class="line">            <span class="comment">//t不为空，t的右侧不为空，那么显然就更新t，然后继续右行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二叉查找树的基础实现"><a href="#二叉查找树的基础实现" class="headerlink" title="二叉查找树的基础实现"></a>二叉查找树的基础实现</h3><p><img src="https://s2.loli.net/2022/04/19/KmcDrg2NfXiwnOG.png"> </p><h3 id="删除方法remove"><a href="#删除方法remove" class="headerlink" title="删除方法remove"></a>删除方法remove</h3><p>删除反而是普通二叉树中最麻烦的事情，因此单独拿出来说<br>一般认为有惰性删除与完全删除<br>惰性删除：把要去除的元素标记为，但是实质并没有把它从树中移除，这种方法除了偷懒之外还有益处，具体为：<br><img src="https://s2.loli.net/2022/04/19/i4d9DqGwXSRBbzy.png"> </p><p>二是完全删除，这个方法就是改变了节点之间的连接方式，彻底将元素移出树<br>理论操作如下，节选自书：<br><img src="https://s2.loli.net/2022/04/19/5BcXv3sdqtYKlb1.png"><br><img src="https://s2.loli.net/2022/04/19/eQXVxCUfMy8KnPW.png"><br>其代码实现如下：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值是子树的新根,x是我们要删除的部分</span></span><br><span class="line"><span class="comment">//实际上包括两个部分，一个是找x,一个是删除x并更新</span></span><br><span class="line"><span class="keyword">private</span> BinaryNodes&lt;AnyType&gt; <span class="title function_">remove</span><span class="params">(AnyType x,BinaryNode&lt;AnyType&gt; t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> t ; </span><br><span class="line">        <span class="comment">//没有这个值就啥都不做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> x.compareTo(t.element) ;</span><br><span class="line">    <span class="keyword">if</span>(compareResult &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.left = remove(x,t.left);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        t.right = remove(x,t.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//% 上述的两个情况，实际上是在递归中查找我们要删掉的那个值</span></span><br><span class="line">        <span class="comment">//% 当我们找到了这个值，递归才会进入下面的情况</span></span><br><span class="line">        <span class="comment">//% 在下面的情况中，分为删除节点有两个节点、没有节点、有一个节点的情况</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right !=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//% 此时我们已经找到了那个要删掉的节点了</span></span><br><span class="line">        <span class="comment">//两个子树的情况</span></span><br><span class="line">        t.element = findMin(t.right).element ; <span class="comment">//% 寻找右子树的最小值，让它替代被删除的节点（值代替）  </span></span><br><span class="line">        t.right = remove(t.element,t.right) ; <span class="comment">//% 断开t该位置和原本位置的链接即可</span></span><br><span class="line">        <span class="comment">//@ 这部分内容可能比较抽象，可以结合p83的图4-24理解</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//剩下的情况就简单了，这个其实才是实质上每次递归最后到达的地方</span></span><br><span class="line">        t = (t.left != <span class="literal">null</span>) ? t.left:t.right ; </span><br><span class="line">        <span class="comment">//若左树不为空，则让该位置变为左树根节点</span></span><br><span class="line">        <span class="comment">//实际就是以“让左树根节点代替删除节点”的方法，一次性完成了删除和更新</span></span><br><span class="line">        <span class="comment">//右树同理。如果没有左树我们就选右树了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平均情况的算法分析"><a href="#平均情况的算法分析" class="headerlink" title="平均情况的算法分析"></a>平均情况的算法分析</h3><p>这部分暂略，表达式的求解在快速排序部分有提及。这里引用书本内容：<br><img src="https://s2.loli.net/2022/04/19/YmbaFxzCNu9vDT7.png"><br><img src="https://s2.loli.net/2022/04/19/plq8fGHuwboQtFA.png"><br><img src="https://s2.loli.net/2022/04/19/tIL8NilVb7zWTpu.png"></p><h2 id="二叉树及相关功能实现（源于MIEC）"><a href="#二叉树及相关功能实现（源于MIEC）" class="headerlink" title="二叉树及相关功能实现（源于MIEC）"></a>二叉树及相关功能实现（源于MIEC）</h2><p>源于课件伪代码进行的实现，建议看源于书本的部分，更详细且更易懂</p><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><p>在二叉树中，按照其规则，最小值位于最左侧，而最大值位于最右侧，这使得我们可以之间向左&#x2F;向右 搜索来得到最值    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findMin(currentRoot)</span><br><span class="line">    while currentRoot.left ≠ NIL</span><br><span class="line">        currentRoot = currentRoot.leftChild</span><br><span class="line">    return currentRoot</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findMax(currentRoot)</span><br><span class="line">    while currentRoot.rightChild ≠ NIL</span><br><span class="line">        currentRoot = currentRoot.rightChild</span><br><span class="line">    return currentRoot</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Insert(currentRoot,node)&#123;</span><br><span class="line">    //接受根以及一个节点作为参数</span><br><span class="line">    if currentRoot == NIL &#123;</span><br><span class="line">        return node ;</span><br><span class="line">        //如果根节点为空，理所当然，我们返回node</span><br><span class="line">        //实质上的意思就是把它作为根节点    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //下面是根节点非空的情况，我们按照大小顺序来进行位置的插入</span><br><span class="line"></span><br><span class="line">    if node.key &lt; currentRoot.key&#123;</span><br><span class="line">        currentRoot.leftChild = insert(currentRoot.leftChild, node);</span><br><span class="line">        //如果node的值比根小，就以根的左值为子树的根，再次向下搜索</span><br><span class="line">        //这里实际上是用了递归  </span><br><span class="line"></span><br><span class="line">    else if(node.key &lt; currentRoot.key)&#123;</span><br><span class="line">        //同理，大于则向右  </span><br><span class="line">        currentRoot.rightChild = insert(currentRoot.leftChild,node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line">        currentRoot.value = node.value ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return currentRoot ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>首先我们可以分析三种最基础的情况<br><img src="https://s2.loli.net/2022/03/14/B5TSAfeUjOxiZb9.png"><br>分别是对应：本来就是叶节点，没有左&#x2F;右 子树的情况<br>对应的解法分别是：直接移除该节点，以及移除该节点后将其右&#x2F;左子树更新到它之前的位置   </p><p>而当要删除的节点的子树情况比较复杂的时候，我们就需要分别考虑并且更新子节点状态<br><img src="https://s2.loli.net/2022/03/14/GmOn9xE7w3FJpgQ.png"> </p><p>那么，怎么挑选继承被删除位置node x的点？则继承的点应该是子树中<strong>最小</strong>的点，同时也应该是<strong>大于x.key</strong>的点   </p><p>依上分析，我们的代码如下:<br>我们利用递归来解决该问题：因为实际上，base case和每一步的操作是比较明了的<br><img src="https://s2.loli.net/2022/03/14/KDaVpWjH1STZ6Md.png"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(currentRoot,key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentRoot == NIL)&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRoot ; </span><br><span class="line">        <span class="comment">//BaseCase:当输入的结果为空时，则返回该节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下移到要删除的点</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; currentRoot)&#123;</span><br><span class="line">        currentRoot.leftChild = delete(currentRoot.leftChild,key) ; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; currentRoot)&#123;</span><br><span class="line">        currentRoot.rightChild = delete(currentRoot.rightChild,key) ; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(currentRoot.leftChild != NIL &amp;&amp; currentRoot.rightChild != NIL)&#123;</span><br><span class="line">        currentRoot.key = findMin(currentRoot.rightChild).key ; </span><br><span class="line">        currentRoot.rightChild = delete(currentRoot.rightChild , currentRoot.key) ; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        current = (currentRoot.leftChild != <span class="literal">null</span>) ? currentRoot.leftChild : currentRoot.rightChild ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentRoot ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">对于树方面的简介，对于二叉树的介绍、实现原理、代码实现，基于《数据结构与算法分析_Java实现》，以及一部分的MIEC课程</summary>
    
    
    
    <category term="MIEC生存手册" scheme="http://example.com/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/"/>
    
    <category term="算法与数据结构" scheme="http://example.com/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="MIEC生存手册" scheme="http://example.com/tags/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>2.1.0 排序算法：快速排序的实现</title>
    <link href="http://example.com/2022/04/19/2.1.0%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/04/19/2.1.0%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-18T18:08:00.000Z</published>
    <updated>2022-08-12T07:32:55.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序算法也是一种分治递归算法，它在 𝑵 值的输入数组上的最坏情况运行时间为 𝜽(𝑵^𝟐)<br>它的平均运行时间为𝜽(𝑵𝐥𝐠𝑵)，但它的平均效率非常高，因为𝜃 𝑁lg𝑁 符号中的常数因子非常小（高度优化的内循环）<br>而且它的最坏情况在简单的优化后可以很可能的避免<br>它具有就地排序的优点，即在不使用辅助数据结构的情况下转换输入（比如归并排序就需要一个辅助数组，否则操作会负责&#x2F;开销会增大）   </p><blockquote><p>在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。    </p></blockquote><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 </p></blockquote><p>该算法的关键是分区过程，它将子数组重新排列到位<br>The key to the algorithm is the partition procedure, which rearranges<br>subarrays in place  </p><blockquote><p>如果您不想被伪代码折磨的话，请跳至：“简易实现”</p></blockquote><h3 id="理论实现"><a href="#理论实现" class="headerlink" title="理论实现"></a>理论实现</h3><p>分：<br>1.选择一个数组中的元素，所选元素被称为<strong>轴&#x2F;基准pivot</strong><br>2.根据所选的轴将数组分为两个子数组，称为data1[l-&gt;p-1],data2[p+1-&gt;r],其中在<strong>data1中的元素一定小于等于轴，而在data2中的元素一定大于等于轴</strong>   </p><p>治：<br>递归调用方法来排序子数组    </p><p>组合：<br>在快排中，不需要合并过程，因为两个子数组已经排序，并且分区方案(即左边都是小的，右边都是大的)确保两个子数组是有序的。  </p><p>注：现在您已经知道基础的知识了，可以选择直接从“快速排序——基于书本的再推进与优化”开始阅读，不过下面的内容不会占用您多少时间。    </p><h4 id="分割区域"><a href="#分割区域" class="headerlink" title="分割区域"></a>分割区域</h4><p>该算法的关键是分区过程，它将子数组重新排列到位,我们可以利用下面的方法来进行分区：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(data,l,r)</span>&#123;</span><br><span class="line">    pivot = data[r] ; </span><br><span class="line">    i = l - <span class="number">1</span> ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j=l to r-<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[j] &lt;= pivot)&#123;</span><br><span class="line">            i++ ; </span><br><span class="line">            swap(data[i] , data[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(data[i+<span class="number">1</span>],data[r]) ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h4><p>分区的策略总体而言还是十分明显的：<br>1.选择轴，一种想法是随机选择三个元素，然后以三个的中位数作为轴；或者取left、right和center的值，然后用三者的中位数作为pivot。不管怎么样，得到一个中位数      </p><blockquote><p>轴的选择对于算法实质执行的时候的速度是十分重要的  </p></blockquote><p>2.按照下方的策略进行分区(伪代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HOARE-PARTITION(data, 𝑙, 𝑟)</span><br><span class="line">    pivot = data[𝑙 ]</span><br><span class="line">    𝑖 = 𝑙 – <span class="number">1</span></span><br><span class="line">    𝑗 = 𝑟 + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> TRUE</span><br><span class="line">        repeat</span><br><span class="line">             𝑗 = 𝑗 − <span class="number">1</span></span><br><span class="line">        until data[ 𝑗 ] &gt; pivot</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            𝑖 = 𝑖 + <span class="number">1</span></span><br><span class="line">        until data[ 𝑖 ] &lt; pivot</span><br><span class="line">        <span class="keyword">if</span> 𝑖 &lt; 𝑗</span><br><span class="line">            SWAP(data[ 𝑖 ], data[ 𝑗 ])</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h3 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] src, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> src[begin];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; src[j] &gt; key) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                src[i] = src[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; src[i] &lt; key) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                src[j] = src[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        src[i] = key;</span><br><span class="line">        quickSort(src, begin, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(src, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序——基于书本的再推进与优化"><a href="#快速排序——基于书本的再推进与优化" class="headerlink" title="快速排序——基于书本的再推进与优化"></a>快速排序——基于书本的再推进与优化</h2><h3 id="简单的快速排序实现"><a href="#简单的快速排序实现" class="headerlink" title="简单的快速排序实现"></a>简单的快速排序实现</h3><p>它实在太简单了：pivot直接选择终点，在分割和比较上不作优化，依旧采用了临时数组等等。这些问题在后文会被逐步优化掉<br>不过，基于这个代码，可以迅速明白快速排序需要干什么  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//% 简单快速排序</span></span><br><span class="line"><span class="comment">//最直观体现快速排序思想的写法，没考虑其他东西，只考虑实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(List&lt;Integer&gt; items)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(items.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//若尺寸大于1，才有的分有的排</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; smaller = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//比pivot小的</span></span><br><span class="line">        List&lt;Integer&gt; larger = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//比pivot大的</span></span><br><span class="line">        List&lt;Integer&gt; same = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//等同pivot的    </span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">chosenItem</span> <span class="operator">=</span> items.get(items.size() / <span class="number">2</span>) ;  <span class="comment">//直接无脑取中间数 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer i : items)&#123;</span><br><span class="line">            <span class="comment">//对于传入数组的每一个数都进行比较  </span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; chosenItem)&#123;</span><br><span class="line">                smaller.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; chosenItem)&#123;</span><br><span class="line">                larger.add(i) ; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                same.add(i) ; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归调用两个部分</span></span><br><span class="line"></span><br><span class="line">        quickSort(smaller);</span><br><span class="line">        quickSort(larger) ; </span><br><span class="line"></span><br><span class="line">        items.clear() ; </span><br><span class="line">        items.addAll(smaller) ; </span><br><span class="line">        items.addAll(same) ; </span><br><span class="line">        items.addAll(larger) ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="经典的快速排序步骤"><a href="#经典的快速排序步骤" class="headerlink" title="经典的快速排序步骤"></a>经典的快速排序步骤</h3><p>分为四步，其中二三两步我们会在后面优化。经典的快速排序不会产生额外的数组，直接在原有数组的基础上进行修改<br>1.如果数组S的元素个数是0或1，直接返回<br>2.取S中任意元素，作为枢纽元pivot<br>3.将S分为两个不相交的集合S1,S2.有一个共同不属于二者的部分v(可能是相等的一组等等)<br>4.返回“S1+v+S2” </p><p>书本原文如下：<br><img src="https://s2.loli.net/2022/04/19/kaK4QPVXOLniUuf.png" alt="MH1R$3US(EO(D1QYNNIGGBB.png">  </p><h3 id="优化：选取合适的pivot"><a href="#优化：选取合适的pivot" class="headerlink" title="优化：选取合适的pivot"></a>优化：选取合适的pivot</h3><p>不想看理论的可以跳到“代码实现”  </p><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>1.首先之首先，使用“第一个&#x2F;最后一个”等作为pivot是十分危险的，因为你面对的数组是未知的<br>2.安全的做法：获得一个随机数，这种策略十分安全，但是获得随机数的开销略大<br>3.三数中值分割法：使用左端、右端、中心位置对应的三个数的中值作为pivot。这种做法能以小的开销，减少程序的调用次数。而由此过程中得到的分割策略是十分优秀的，并且在分割过程中的优化可以为后面程序的运行铺垫（这部分解释起来篇幅有点大，见P220-P202）   </p><p>书中的原文：<br>![M0LKJZA2U]6[(IF&#96;<a href="mailto:&#85;&#x51;&#x50;&#x40;&#x54;&#x57;&#x59;&#46;&#112;&#110;&#103;">&#85;&#x51;&#x50;&#x40;&#x54;&#x57;&#x59;&#46;&#112;&#110;&#103;</a>](<a href="https://s2.loli.net/2022/04/19/XVz39NL5WkbMmGC.png">https://s2.loli.net/2022/04/19/XVz39NL5WkbMmGC.png</a>)  </p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>三值分割法是开销小且好用的一种方法：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//@ 该部分做法的理由和作用见P202</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Anytype <span class="title function_">median3</span><span class="params">(Anytype[] a , <span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> (left+right)/<span class="number">2</span> ; </span><br><span class="line">    <span class="keyword">if</span>(a[center].compareTo(a[left]) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//中位小于左，换值</span></span><br><span class="line">        SwapReferences(a,left,center);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a[right].compareTo(a[left]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//右位小于左，换值</span></span><br><span class="line">        SwapReferences(a,left,right) ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a[right].compareTo(a[center]) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//右位小于中，换值</span></span><br><span class="line">        SwapReferences(a,center,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SwapReferences(a,center,right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> a[right - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SwapReferences</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line"></span><br><span class="line">    a[i] = a[j];</span><br><span class="line"></span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化：小数组处理"><a href="#优化：小数组处理" class="headerlink" title="优化：小数组处理"></a>优化：小数组处理</h3><h4 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h4><p>个人认为，只是应试的话（比如强制使用快排），可以不看这部分的优化<br>起因<strong>对于“小数组”，快排不如插入排序</strong>，通常的解决办法是在数组较小时不递归调用快排，转而使用插入排序    </p><p>那么，多“小”是小呢，一般认为，一种好的截止范围Cutoff Range是10，即CUTOFF&#x3D;10。事实上5到20都可以，但是为了避免各种极端情况的发生时的“有害退化出现”，我们选择10<br>书中原文的阐述如下：<br><img src="https://s2.loli.net/2022/04/19/qaFfrEuV8nXWbvQ.png"> </p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>其实就是一个if-else的事情，这部分直接写到最终的实现代码里面去了 </p><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>由上分析综合得出以下代码（含注释）：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//% 优化后的快速排序</span></span><br><span class="line"><span class="comment">//优化的方法和理论相关见书P198-P203</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//% 驱动程序</span></span><br><span class="line"><span class="comment">//和归并类似，这里不再赘述</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(Anytype[] a)</span>&#123;</span><br><span class="line">    quickSort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//% 执行三数中值分割法的程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@ 该部分做法的理由和作用见P202</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Anytype <span class="title function_">median3</span><span class="params">(Anytype[] a , <span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> (left+right)/<span class="number">2</span> ; </span><br><span class="line">    <span class="keyword">if</span>(a[center].compareTo(a[left]) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//中位小于左，换值</span></span><br><span class="line">        SwapReferences(a,left,center);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a[right].compareTo(a[left]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//右位小于左，换值</span></span><br><span class="line">        SwapReferences(a,left,right) ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a[right].compareTo(a[center]) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//右位小于中，换值</span></span><br><span class="line">        SwapReferences(a,center,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SwapReferences(a,center,right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> a[right - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SwapReferences</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line"></span><br><span class="line">    a[i] = a[j];</span><br><span class="line"></span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//% 快速排序算法的主例程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(Anytype[] a , <span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left + CUTOFF &lt;= right)&#123;</span><br><span class="line">        <span class="comment">//! 这里的CUTOFF是截止范围的意思（该部分描述见P202）,一般选10作为截止即可</span></span><br><span class="line">        <span class="type">Anytype</span> <span class="variable">pivot</span> <span class="operator">=</span> median3(a,left,right) ; <span class="comment">//三数中值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是排序主体</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left ; </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right - <span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="comment">//没意外会一直循环，如何断开于代码部分控制  </span></span><br><span class="line">            <span class="keyword">while</span>(a[++i].compareTo(pivot)&lt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(a[--j].compareTo(pivot)&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上述代码的作用实质上是移动i j 两下标的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                SwapReferences(a,i,j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SwapReferences(a,i,right-<span class="number">1</span>); <span class="comment">//固定pivot</span></span><br><span class="line"></span><br><span class="line">        quickSort(a,left,i-<span class="number">1</span>);<span class="comment">//小的部分的递归</span></span><br><span class="line">        quickSort(a,i+<span class="number">1</span>,right) ; <span class="comment">//打的部分的递归</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//@ 优化部分，对于总数小的数组，采用另外一种排序方式 P202</span></span><br><span class="line">        <span class="comment">//如果只用快排，那么把这部分的if-else去掉</span></span><br><span class="line">        insertionSort(a,left,right);<span class="comment">//比如使用插入排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">归并排序，基于《数据结构与算法分析_Java实现》，以及一部分的MIEC课程</summary>
    
    
    
    <category term="MIEC生存手册" scheme="http://example.com/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/"/>
    
    <category term="算法与数据结构" scheme="http://example.com/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="MIEC生存手册" scheme="http://example.com/tags/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>2.0 排序算法：归并排序</title>
    <link href="http://example.com/2022/04/19/2.0%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/04/19/2.0%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2022-04-18T18:00:00.000Z</published>
    <updated>2022-08-12T07:32:52.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是一种高效的基于比较的分治递归算法<br>合并排序在 𝑶𝑵𝐥𝐠𝑵 在最坏情况和平均情况下运行，算法使用的比较次数几乎是最优的 </p><blockquote><p>Merge sort runs in 𝑶 𝑵𝐥𝐠𝑵 both worst-case and average-case running time and the number of comparisons used by the algorithm is nearly optimal.  </p></blockquote><p>归并排序的许多实现是稳定的，即输入和输出中相等元素的顺序是相同的  </p><blockquote><p>归并排序：将待排序的元素序列分成两个子序列，每个子序列有N&#x2F;2个元素 </p></blockquote><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>归并排序算法遵循分而治之的范式，<strong>将问题划分为多个子问题，这些子问题是同一问题的较小实例</strong><br>通过递归解决子问题来完成算法,将子问题的解组合成原问题的解    </p><blockquote><p>归并排序：对两个子序列进行递归排序,合并两个排序的子序列以产生排序的答案    </p></blockquote><blockquote><p>1.Divide the problem into a number of subproblems that are smaller instances of the same problem<br>2.Conquer the subproblems by solving them recursively<br>3.Combine the solutions to the subproblems into the solution for the original problem</p></blockquote><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>在这个图解中，假设了A、B均是非递减数组，实质上在我们后面利用递归计算的时候，不用考虑传入数组的性质的<br><img src="https://s2.loli.net/2022/04/19/9HelJjhF2tpU35w.png"> </p><p><strong>说白了，归并的核心步骤在于“从A&#x2F;B数组中找到较小值并加入于C中”</strong><br>另外，合并两个已排序的表的时间是线性的，这一点在算法分析的时候会用到    </p><h3 id="实现：书本实现"><a href="#实现：书本实现" class="headerlink" title="实现：书本实现"></a>实现：书本实现</h3><p>先谈谈书本的实现，个人认为更好理解而且适用性更高    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//% 主要例程，mergeSort。其中public表达是驱动private方法的方式  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(AnyType [] a)</span>&#123;</span><br><span class="line">    AnyType[] tmpArray = (AnyType[]) <span class="keyword">new</span> <span class="title class_">Comparable</span> [a.length] ; </span><br><span class="line">    <span class="comment">//事实上，这里的Comparable有可能成为后续开销的主要来源，见P197的解释</span></span><br><span class="line"></span><br><span class="line">    mergeSort(a,tempArray,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//% mergeSort真正执行的方法 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一个目标数组a</span></span><br><span class="line"><span class="comment">    一个临时存储数组tempArray</span></span><br><span class="line"><span class="comment">    左右的端点left right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(AnyType [] a , AnyType[] tempArray , <span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">//相等即完成</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> (left + right) / <span class="number">2</span> ; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//分治之分，旨在对left和right两边进行再排序直到baseCase</span></span><br><span class="line">        mergeSort(a,tempArray,left,center) ; </span><br><span class="line">        mergeSort(a,tempArray,center+<span class="number">1</span>,right) ; </span><br><span class="line"></span><br><span class="line">        merge(a,tempArray,left,center+<span class="number">1</span>,right) ; </span><br><span class="line">        <span class="comment">//进行合并（“治”）的方法，见后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//% merge 进行合并的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一个目标数组a</span></span><br><span class="line"><span class="comment">    一个临时存储数组tempArray</span></span><br><span class="line"><span class="comment">    左端点left</span></span><br><span class="line"><span class="comment">    右侧数组的起始点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(AnyType[] a , AnyType[] tempArray , <span class="type">int</span> left , <span class="type">int</span> rightPoint , <span class="type">int</span> rightEnd)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> rightPoint - <span class="number">1</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temPos</span> <span class="operator">=</span> left ; <span class="comment">//结果数组的下标    </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numElements</span> <span class="operator">=</span> rightEnd - left + <span class="number">1</span> ;<span class="comment">//元素总数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要进行填入的循环</span></span><br><span class="line">    <span class="comment">//核心思想：比较两个数组的最小值，填入二者中的较小者。一个数组填完之后就直接填另外一个数组所有的东西</span></span><br><span class="line">    <span class="comment">//这个步骤对于递归的每一步都是适用的    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= leftEnd &amp;&amp; rightPoint &lt;= rightEnd )&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[left].compareTo(a[rightPoint]) &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">            tempArray[temPos++] = a[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tempArray[temPos++] = a[rightPoint++] ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=leftEnd)&#123;</span><br><span class="line">            tempArray[temPos++] = a[left++] ; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rightPoint &lt;= rightEnd)&#123;</span><br><span class="line">            tempArray[temPos++] = a[rightPoint++] ; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Copy数组，得到结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; numElements ; i++)&#123;</span><br><span class="line">            a[rightEnd] = tempArray[rightEnd] ; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现：百度百科"><a href="#实现：百度百科" class="headerlink" title="实现：百度百科"></a>实现：百度百科</h3><p>这部分实现来自百度百科，几乎没有注释，仅仅作为补充<br>可以用以下代码，佐以递归，实现归并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mergeSort(data,left,right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        center = (left+right)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//归，分的过程</span></span><br><span class="line">        mergeSort(data,left,center);</span><br><span class="line">        mergeSort(data,center+<span class="number">1</span>,right) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并，合起来</span></span><br><span class="line">        merger(data,left,center,right) ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merge(data, left, centre, right)</span><br><span class="line">    n1= centre – left + <span class="number">1</span></span><br><span class="line">    n2= right - centre</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立一个新数组</span></span><br><span class="line">    let L[ <span class="number">0.</span>.n1] and R[ <span class="number">0.</span>. n2] be <span class="keyword">new</span> <span class="title class_">arrays</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//填充数组</span></span><br><span class="line">    <span class="keyword">for</span> 𝑖= <span class="number">0</span> to n1</span><br><span class="line">        L[ 𝑖] = data[ left + 𝑖]</span><br><span class="line">    <span class="type">for</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ton <span class="number">2</span></span><br><span class="line">        R[ 𝑗] = data[ centre + 𝑗]</span><br><span class="line">    </span><br><span class="line">    L[ n1] = R[ n2] = ∞</span><br><span class="line">    𝑖= 𝑗= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较与更新数组</span></span><br><span class="line">    <span class="keyword">for</span> 𝑘= left toright</span><br><span class="line">        <span class="keyword">if</span> L[ 𝑖] ≤R[ 𝑗]</span><br><span class="line">            data[ 𝑘] = L[ 𝑖++ ]</span><br><span class="line">        <span class="keyword">else</span> data[ 𝑘] = R[ j++ ]</span><br></pre></td></tr></table></figure><h3 id="实现——完全代码：百度百科"><a href="#实现——完全代码：百度百科" class="headerlink" title="实现——完全代码：百度百科"></a>实现——完全代码：百度百科</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;; <span class="comment">//测试数组</span></span><br><span class="line">        mergeSort(arr);</span><br><span class="line">        System.out.println(Array.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> []arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> []temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.lengrh] ; <span class="comment">//可以在这里的排序前就先建立一个临时数组，避免递归中频繁开辟新空间   </span></span><br><span class="line"></span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp) ; <span class="comment">//递归调用一个重载的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[]arr,<span class="type">int</span> left , <span class="type">int</span> right , <span class="type">int</span>[]temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">//左还小于右，就说明还没结束</span></span><br><span class="line">            <span class="comment">//等于时就是BaseCase</span></span><br><span class="line"></span><br><span class="line">            mergeSort(arr,left,mid,temp) ; </span><br><span class="line">            mergeSort(arr,mid+<span class="number">1</span>,right,temp) ; </span><br><span class="line">            merge(arr,left,mid,right,temp) ; <span class="comment">//利用一个方法进行合并</span></span><br><span class="line">            <span class="comment">//而且，需要每次合并完才可进行下一次归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr , <span class="type">int</span> left , <span class="type">int</span> mid , <span class="type">int</span> right , <span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left ; </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right ; </span><br><span class="line">        <span class="comment">//小小利用一下双指针进行排序</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span> ;<span class="comment">//结果数组，即之前的临时数组的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//当i j 两边都没排完的时候，我们需要根据二者对应的数值的大小来选择放入临时数组的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= j&lt;=right)&#123;</span><br><span class="line">                temp[t++] = arr[i++] ; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t++] = arr[j++] ; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在一边耗完的情况下，把另外一组按顺序排入即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将结果拷贝至原数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序的算法分析"><a href="#归并排序的算法分析" class="headerlink" title="归并排序的算法分析"></a>归并排序的算法分析</h3><p>结论：𝑻(𝑵) &#x3D; 𝜽(𝑵𝐥𝐠𝑵)    </p><p>见前文，我们知道了“合并两个已排序的表的时间是线性的” ，舍合并为N<br>另外，设<strong>一次归并排序的完成时间</strong>为T(N),其中T(1) &#x3D; 1<br>那么，我们知道一次归并排序实际上是：<strong>归并排序 &#x3D; 左侧归并+右侧归并+合并</strong>，显然左右的大小可以视作相等，于是可得：<br>表达式：T(N) &#x3D; 2*T(N&#x2F;2)+N   ,T(1) &#x3D; 1<br>书中的原文表述为：<br><img src="https://s2.loli.net/2022/04/19/qgs2tPjw59yMApe.png"><br><img src="https://s2.loli.net/2022/04/19/rNutK3oOc2iUMWg.png"><br>然后我们可以一直令N &#x3D; N&#x2F;2 推公式，并且上下相加削减左右，具体为：<br><img src="https://s2.loli.net/2022/04/19/xdeKoC5OmGcWTX4.png"><br>将上述式子逐步相加，于是可以得：<br><img src="https://s2.loli.net/2022/04/19/Wco4BwlZ9bDiM8T.png"> </p><p>另外，还有一种方式推出公式，于书P197页，这里不再赘述    </p><p>最后附上MIEC CS211课间中的推导图，和本文的方式是完全一样的：<br><img src="https://s2.loli.net/2022/04/19/UXpEWGIkb7joRwC.png" alt="image.png">    </p>]]></content>
    
    
    <summary type="html">归并排序，基于《数据结构与算法分析_Java实现》，以及一部分的MIEC课程</summary>
    
    
    
    <category term="MIEC生存手册" scheme="http://example.com/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/"/>
    
    <category term="算法与数据结构" scheme="http://example.com/categories/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="MIEC生存手册" scheme="http://example.com/tags/MIEC%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>Unity对话控制系统</title>
    <link href="http://example.com/2022/03/10/Unity%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F(%E6%8E%A7%E5%88%B6)/"/>
    <id>http://example.com/2022/03/10/Unity%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F(%E6%8E%A7%E5%88%B6)/</id>
    <published>2022-03-10T13:30:33.000Z</published>
    <updated>2022-08-12T07:49:50.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity对话控制系统"><a href="#Unity对话控制系统" class="headerlink" title="Unity对话控制系统"></a>Unity对话控制系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对话系统一直是游戏中重要的一部分，该部分就简单而言，可以只要对话的更新，显示即可。而复杂情况下，可能还需要配合小到给予物品、发生事件，大到结局分支，都与它有关<br>本文将就对话系统一方面，进行一步步步的开发研究和加强，建立一个比较完善+有扩展性的对话系统<br>可能用到的设计模式(蛮写、知不知道无所谓)：单例、观察者  </p><p>(有机会的话后面补上视频)</p><h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>对于一个对话框，我们这里设置了<strong>对话内容</strong>，<strong>头像</strong>，<strong>人物姓名</strong>三个方面，我们先声明对应的变量<br>并且在<code>Awake()</code>中写下系列代码，帮助我们使用单例<br>最终结果如下    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiaLogManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DiaLogManager instance ; </span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基础部分&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> GameObject textBackground ;</span><br><span class="line">    <span class="keyword">public</span> Image speakerPic ;</span><br><span class="line">    <span class="keyword">public</span> Text speakerName ; </span><br><span class="line">    <span class="keyword">public</span> Text speakertext ; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span> )&#123;</span><br><span class="line">            instance = <span class="keyword">this</span> ;</span><br><span class="line">            <span class="comment">//设置instance</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="keyword">this</span>)&#123;</span><br><span class="line">                Destroy(gameObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DontDestroyOnLoad(gameObject);  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里写的是对应组件的绑定，你也可以写成自己的，或者用拖动的方式绑定    </span></span><br><span class="line">        <span class="comment">//这一部分不是该文章的重点，如果你想了解这方面，可以参考另外一篇博文:《在Unity中查找Active为false的物体》</span></span><br><span class="line">        textBackground = ((GameObject.Find(<span class="string">&quot;UI&quot;</span>)).transform.Find(<span class="string">&quot;TextBackGround&quot;</span>).gameObject) ; </span><br><span class="line">        speakerPic = textBackground.transform.Find(<span class="string">&quot;speakerPic&quot;</span>).GetComponent&lt;Image&gt;() ;</span><br><span class="line">        speakerName = textBackground.transform.Find(<span class="string">&quot;speakerName&quot;</span>).GetComponent&lt;Text&gt;() ;</span><br><span class="line">        speakertext = textBackground.transform.Find(<span class="string">&quot;speakertext&quot;</span>).GetComponent&lt;Text&gt;() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们的设想是，根据每个有需要对话框的实体(NPC,告示牌等等)来触发这个对话框，也就是说对话的内容是储存在<strong>需要对话框的实体</strong>那里的<br>因此我们建立一个<code>string</code>的数组来得到对话内容，并且使用一个<code>text_index</code>来记录对话下标，然后通过一个函数来读取对话内容<br>于是我们写下    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadDialog</span>(<span class="params"><span class="built_in">string</span>[] _texts</span>)</span>&#123;</span><br><span class="line">    texts = <span class="keyword">new</span> <span class="built_in">string</span>[_texts.Length] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; _texts.Length ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        texts[i] = _texts[i]  ; </span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;复制完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NPC类"><a href="#NPC类" class="headerlink" title="NPC类"></a>NPC类</h3><p>我们通过一个类来抽象我们的NPC，现在它的功能十分简单，只要先写出NPC需要有声明属性即可    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NPC</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Image speakerPic ;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> speakerName ; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] speakertext ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="补充对话框"><a href="#补充对话框" class="headerlink" title="补充对话框"></a>补充对话框</h3><p>然后再在<code>DiaLogManager</code>中写在每次加载的函数<br>这里我们分别写了三个函数来进行加载头像、姓名、内容: </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadImage</span>(<span class="params">Image _image</span>)</span>&#123;</span><br><span class="line">    speakerPic = _image ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadName</span>(<span class="params"><span class="built_in">string</span> _name</span>)</span>&#123;</span><br><span class="line">    speakerName.text = _name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadDialog</span>(<span class="params"><span class="built_in">string</span>[] _texts</span>)</span>&#123;</span><br><span class="line">    texts = <span class="keyword">new</span> <span class="built_in">string</span>[_texts.Length] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; _texts.Length ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        texts[i] = _texts[i]  ; </span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;复制完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之前定义了NPC类，于是我们可以整合三个方法为一个方法 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSpeaker</span>(<span class="params">NPC _npc</span>)</span>&#123;</span><br><span class="line">    LoadImage(_npc.speakerPic);</span><br><span class="line">    LoadName(_npc.speakerName);</span><br><span class="line">    LoadDialog(_npc.speakertext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的优势在于：我们只要在对应的NPC的代码中调用该函数即可<br>而且之后我们有什么特殊的要求，可以对方法进行重载，或者直接单独调用对应的方法    </p><p>此时，基本的载入功能已经完成，目前代码如下：    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiaLogManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DiaLogManager instance ; </span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基础部分&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> GameObject textBackground ;</span><br><span class="line">    <span class="keyword">public</span> Image speakerPic ;</span><br><span class="line">    <span class="keyword">public</span> Text speakerName ; </span><br><span class="line">    <span class="keyword">public</span> Text speakertext ; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span> )&#123;</span><br><span class="line">            instance = <span class="keyword">this</span> ;</span><br><span class="line">            <span class="comment">//设置instance</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="keyword">this</span>)&#123;</span><br><span class="line">                Destroy(gameObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DontDestroyOnLoad(gameObject);  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        textBackground = ((GameObject.Find(<span class="string">&quot;UI&quot;</span>)).transform.Find(<span class="string">&quot;TextBackGround&quot;</span>).gameObject) ; </span><br><span class="line">        speakerPic = textBackground.transform.Find(<span class="string">&quot;speakerPic&quot;</span>).GetComponent&lt;Image&gt;() ;</span><br><span class="line">        speakerName = textBackground.transform.Find(<span class="string">&quot;speakerName&quot;</span>).GetComponent&lt;Text&gt;() ;</span><br><span class="line">        speakertext = textBackground.transform.Find(<span class="string">&quot;speakertext&quot;</span>).GetComponent&lt;Text&gt;() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSpeaker</span>(<span class="params">NPC _npc</span>)</span>&#123;</span><br><span class="line">        LoadImage(_npc.speakerPic);</span><br><span class="line">        LoadName(_npc.speakerName);</span><br><span class="line">        LoadDialog(_npc.speakertext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public void </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadImage</span>(<span class="params">Image _image</span>)</span>&#123;</span><br><span class="line">        speakerPic = _image ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadName</span>(<span class="params"><span class="built_in">string</span> _name</span>)</span>&#123;</span><br><span class="line">        speakerName.text = _name ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadDialog</span>(<span class="params"><span class="built_in">string</span>[] _texts</span>)</span>&#123;</span><br><span class="line">        texts = <span class="keyword">new</span> <span class="built_in">string</span>[_texts.Length] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; _texts.Length ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            texts[i] = _texts[i]  ; </span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;复制完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="补充开关对话已经文本更新"><a href="#补充开关对话已经文本更新" class="headerlink" title="补充开关对话已经文本更新"></a>补充开关对话已经文本更新</h3><p>之后我们按需写下两个方法，用于打开和关闭对话框  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OpenDialog</span>()</span>&#123;</span><br><span class="line">    isOpenDialog = <span class="literal">true</span> ;</span><br><span class="line">    textIndex = <span class="number">0</span> ;</span><br><span class="line">    speakertext.text = texts[textIndex] ;</span><br><span class="line">    textBackground.SetActive(<span class="literal">true</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseDialog</span>()</span>&#123;</span><br><span class="line">    isOpenDialog = <span class="literal">false</span> ;</span><br><span class="line">    textBackground.SetActive(<span class="literal">false</span>);</span><br><span class="line">    textIndex = <span class="number">0</span>  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说明一下，这个textBackground对应的是对话框的UI组件，在Unity的编辑器窗口中，它是：<br><img src="https://s2.loli.net/2022/03/10/iphtMcPe71OGFZl.png"> </p><p>下面写出对话框内容更新的方法：本质是对对话框数组下标的递增：    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NextString</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isOpenDialog)&#123;</span><br><span class="line">        OpenDialog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(textIndex &gt;= texts.Length)&#123;</span><br><span class="line">        CloseDialog();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        speakertext.text = texts[textIndex] ;</span><br><span class="line">        textIndex++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时整体的代码如下，下一步我们会配合NPC的对应脚本，完成基础的对话框功能 </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们预想中的对话逻辑是：玩家碰到NPC，玩家选择交互，出对话框<br>或者NPC如果是告示牌之类的，就不用玩家选择交互，而是直接跳出对话框   </p><p>此外，我们在<code>OnOnTriggerEnter2D</code>代码中，判断是瞬时的，也就是说<strong>玩家按下按键</strong>这一部分不应该写在这里<br>于是对应的，交互逻辑即 玩家碰到NPC-&gt;NPC改为可交互状态-&gt;此时玩家如果按下F就进入交互状态<br>这部分代码修改如下: </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NPC</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基础对话框&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> Image speakerPic ;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> speakerName ; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] speakertext ; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isTips ; <span class="comment">//如果是告示牌，则采用直接跳出对话框的方式 </span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;交互&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canTakeAction ; <span class="comment">//可以交互 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isTakeAction ; <span class="comment">//是否已经在交互状态    </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(canTakeAction &amp;&amp; Input.GetKeyDown(KeyCode.F))&#123;</span><br><span class="line">            isTakeAction = <span class="literal">true</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isTakeAction)&#123;</span><br><span class="line">            <span class="comment">//进行交互</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EndAction</span>()</span>&#123;</span><br><span class="line">        <span class="comment">//结束交互</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(other.tag == <span class="string">&quot;Player&quot;</span>)&#123;</span><br><span class="line">            canTakeAction = <span class="literal">true</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        canTakeAction = <span class="literal">false</span> ; </span><br><span class="line">        isTakeAction = <span class="literal">false</span> ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们选出交互实现的部分，我们想在进入交互后，玩家按下F则进入对话框<br>而对话结束后，结束交互  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isTakeAction)&#123;</span><br><span class="line">    <span class="comment">//进行交互</span></span><br><span class="line">    DiaLogManager.instance.LoadSpeaker(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.F))&#123;</span><br><span class="line">        DiaLogManager.instance.NextString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    EndAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，个人认为<strong>结束和关闭对话框</strong>这一部分也要交给NPC管理，于是我们可以修改一下<code>DiaLogManger</code>的<code>NextString()</code>如下： </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">NextString</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isOpenDialog)&#123;</span><br><span class="line">        OpenDialog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(textIndex &gt;= texts.Length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        speakertext.text = texts[textIndex] ;</span><br><span class="line">        textIndex++ ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且将NPC部分的交互改为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isTakeAction)&#123;</span><br><span class="line">    <span class="comment">//进行交互</span></span><br><span class="line">    DiaLogManager.instance.LoadSpeaker(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.F))&#123;</span><br><span class="line">        isTakeAction = DiaLogManager.instance.NextString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    EndAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且补全<code>EndAction()</code>方法如下： </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EndAction</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//结束交互</span></span><br><span class="line">    isTakeAction = <span class="literal">false</span> ; </span><br><span class="line">    DiaLogManager.instance.CloseDialog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>目前最基本的对话框内容就是这样了,进阶的配合请见另外一篇文章<br>目前用到的两个脚本的完整代码如下:   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">```C#</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI ; </span><br><span class="line"></span><br><span class="line">public class DiaLogManager : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public static DiaLogManager instance ; </span><br><span class="line">    [Header(&quot;基础部分&quot;)]</span><br><span class="line">    public GameObject textBackground ;</span><br><span class="line">    public Image speakerPic ;</span><br><span class="line">    public Text speakerName ; </span><br><span class="line">    public Text speakertext ; </span><br><span class="line">    [Header(&quot;对话框内容&quot;)]</span><br><span class="line">    public bool isOpenDialog ;</span><br><span class="line">    public string[] texts ;</span><br><span class="line">    public int textIndex ; </span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if(instance == null )&#123;</span><br><span class="line">            instance = this ;</span><br><span class="line">            //设置instance</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(instance != this)&#123;</span><br><span class="line">                Destroy(gameObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DontDestroyOnLoad(gameObject);  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        textBackground = ((GameObject.Find(&quot;UI&quot;)).transform.Find(&quot;TextBackGround&quot;).gameObject) ; </span><br><span class="line">        speakerPic = textBackground.transform.Find(&quot;speakerPic&quot;).GetComponent&lt;Image&gt;() ;</span><br><span class="line">        speakerName = textBackground.transform.Find(&quot;speakerName&quot;).GetComponent&lt;Text&gt;() ;</span><br><span class="line">        speakertext = textBackground.transform.Find(&quot;speakertext&quot;).GetComponent&lt;Text&gt;() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OpenDialog()&#123;</span><br><span class="line">        isOpenDialog = true ;</span><br><span class="line">        textIndex = 0 ;</span><br><span class="line">        speakertext.text = texts[textIndex] ;</span><br><span class="line">        textBackground.SetActive(true) ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void CloseDialog()&#123;</span><br><span class="line">        isOpenDialog = false ;</span><br><span class="line">        textBackground.SetActive(false);</span><br><span class="line">        textIndex = 0  ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void LoadSpeaker(NPC _npc)&#123;</span><br><span class="line">        LoadImage(_npc.speakerPic);</span><br><span class="line">        LoadName(_npc.speakerName);</span><br><span class="line">        LoadDialog(_npc.speakertext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //public void </span><br><span class="line">    public void LoadImage(Sprite _image)&#123;</span><br><span class="line">        speakerPic.sprite = _image ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void LoadName(string _name)&#123;</span><br><span class="line">        speakerName.text = _name ;</span><br><span class="line">    &#125;</span><br><span class="line">    public void LoadDialog(string[] _texts)&#123;</span><br><span class="line">        texts = new string[_texts.Length] ;</span><br><span class="line">        for (int i = 0 ; i &lt; _texts.Length ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            texts[i] = _texts[i]  ; </span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(&quot;复制完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public bool NextString()&#123;</span><br><span class="line">        if(!isOpenDialog)&#123;</span><br><span class="line">            OpenDialog();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(textIndex &gt;= texts.Length)&#123;</span><br><span class="line">            return false ;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            speakertext.text = texts[textIndex] ;</span><br><span class="line">            textIndex++ ;</span><br><span class="line">            return true ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">```C#</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI ;</span><br><span class="line"></span><br><span class="line">public class NPC : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [Header(&quot;基础对话框&quot;)]</span><br><span class="line">    public Sprite speakerPic ;</span><br><span class="line">    public string speakerName ; </span><br><span class="line">    public string[] speakertext ; </span><br><span class="line">    public bool isTips ; //如果是告示牌，则采用直接跳出对话框的方式 </span><br><span class="line"></span><br><span class="line">    [Header(&quot;交互&quot;)]</span><br><span class="line">    [SerializeField]private bool canTakeAction = false ; //可以交互 </span><br><span class="line">    [SerializeField]private bool isTakeAction = false ; //是否已经在交互状态    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if(canTakeAction &amp;&amp; Input.GetKeyDown(KeyCode.F))&#123;</span><br><span class="line">            isTakeAction = true ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(isTakeAction)&#123;</span><br><span class="line">            //进行交互</span><br><span class="line">            DiaLogManager.instance.LoadSpeaker(this);</span><br><span class="line">            if(Input.GetKeyDown(KeyCode.F))&#123;</span><br><span class="line">                isTakeAction = DiaLogManager.instance.NextString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            EndAction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void EndAction()&#123;</span><br><span class="line">        //结束交互</span><br><span class="line">        isTakeAction = false ; </span><br><span class="line">        DiaLogManager.instance.CloseDialog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnTriggerEnter2D(Collider2D other)</span><br><span class="line">    &#123;</span><br><span class="line">        if(other.tag == &quot;Player&quot;)&#123;</span><br><span class="line">            canTakeAction = true ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnTriggerExit2D(Collider2D other)</span><br><span class="line">    &#123;</span><br><span class="line">        canTakeAction = false ; </span><br><span class="line">        isTakeAction = false ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于Unity中对话系统的制作</summary>
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>【基础C语言】七、其他内容</title>
    <link href="http://example.com/2022/03/08/%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2022/03/08/%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/</id>
    <published>2022-03-08T04:00:00.000Z</published>
    <updated>2022-03-08T16:48:15.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、其他内容"><a href="#七、其他内容" class="headerlink" title="七、其他内容"></a>七、其他内容</h1><p>这里包含了一些C语言的其他内容<br>包含:宏、大程序建立、位和位运算、可变数组、链表<br>这一部分比较多而杂,建议妥善选取所需</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>定义在函数外面的变量是全局变量</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>全局变量具有<strong>全局的</strong>生存期和作用类<br>它们与任何函数都无关，在任何函数内部都可以使用它们  </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>没有初始化的全局变量会得到0值，而指针会得到NULL值<br>只能用在<strong>编译时刻，已知的值</strong>来初始化全局变量<br>它们的初始化发生在main函数之前  </p><p>Tips:<br>即使是  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> gAll = <span class="number">12</span> ; </span><br><span class="line"><span class="type">int</span> g2 = gAll ;</span><br></pre></td></tr></table></figure><p>也会被认为是“用编译时未知的值初始化”</p><p>但是，如果已经保证了该变量不会变化(即是const)，就可以通过编译   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> gAll = <span class="number">12</span> ; </span><br><span class="line"><span class="type">int</span> g2 = gAll ; </span><br></pre></td></tr></table></figure><blockquote><p>但是，不建议一个全局变量和另外一个全局变量联系    </p></blockquote><h3 id="隐藏全局变量"><a href="#隐藏全局变量" class="headerlink" title="隐藏全局变量"></a>隐藏全局变量</h3><p>如果在函数内部存在与全局变量同名的变量，则全局变量会被隐藏<br>或者说，在“更小的范围内”重新定义了同名的变量，“更大范围中”的变量会被隐藏    </p><blockquote><p>允许在更小的地方重新定义一个定义过的变量  </p></blockquote><h2 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a>静态本地变量</h2><p>在本地变量定义的时候加上<code>static</code>修饰符即可让它成为静态本地变量  </p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当函数离开的时候，静态本地变量会继续存在并保持其值<br>静态本地变量的初始化只会在<strong>第一次</strong>进入这个函数时进行<br>在之后进入函数会保持上次离开时的值  </p><p>静态本地变量实际上是<strong>特殊</strong>的全局变量  </p><blockquote><p>它们是位于相同的内存区域的<br>静态本地变量具有全局本地的生存期，函数内的局部作用域    </p></blockquote><p><strong>静态本地变量 &#x3D; 全局生存期+局部作用域</strong>    </p><h3 id="贴士"><a href="#贴士" class="headerlink" title="贴士"></a>贴士</h3><p>返回的本地变量的地址是危险的<br>返回的全局变量&#x2F;静态本地变量的地址是安全的   </p><p>返回在函数内的malloc的内存是安全的，但容易造成问题<br>最好的做法是返回<strong>传入的指针</strong>  </p><p>不要使用全局变量来在函数间传递参数和结果<br>尽量避免使用全局变量    </p><blockquote><p>使用全局变量和静态本地变量的函数是线程不安全的</p></blockquote><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h3><p>以<code>#</code>开头的是编译预处理指令<br>它们不是C语言的成分，但是C语言程序离不开它们<br>使用<code>#define</code>来定义一个<strong>宏</strong><br>注意，后面不用接上分号<br><strong>绝对不能加分号</strong>，在替换后及其容易影响到代码  </p><figure class="highlight plaintext"><figcaption><span><符号的名字> <符号的值>```，比如</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```#define PI 3.14159```</span><br><span class="line"></span><br><span class="line">```#define```所做的就是最原始的“替换”   </span><br><span class="line">也就是在预处理的时候，把下面代码中的&lt;符号的名字&gt;全部替换为&lt;符号的值&gt;    </span><br><span class="line">&gt; 在C语言的编译器还是编译之前，编译预处理程序(CPP)会把程序中的名字换成值</span><br><span class="line">&gt; 是完全的文本替换</span><br><span class="line">名字必须是一个单词，而值可以是各种东西  </span><br><span class="line"></span><br><span class="line">### 使用</span><br><span class="line">如果一个宏的值中有其他宏的名字，也是会被替换的  </span><br><span class="line">如果一个宏的值超过一行，最后一行之前的行末需要加```\```表示下一行仍然是该宏的值  </span><br><span class="line">宏的值后面出现的注释不会被当作宏的值的一部分    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#define PI 3.14<br>#define PI2 2*PT &#x2F;&#x2F;这里是注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">最终的结果会变成    把PI2变成2*3.14 </span><br><span class="line"></span><br><span class="line">#### 没有值的宏</span><br><span class="line">```#define _DEBUG```</span><br><span class="line">这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是各已经被定义过了    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 带参数的宏   </span><br><span class="line"></span><br><span class="line">### 例子</span><br><span class="line">```#define cube(x) ((x)*(x)*(x))```</span><br><span class="line">举个例子，此时我们写:</span><br><span class="line">```c</span><br><span class="line">#define cube(x) ((x)*(x)*(x)) </span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;%d \n&quot; , cube(5)) ; </span><br><span class="line">    </span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时对于cube(5)，在过程中有以下变化<br><code>cube(5)-&gt;((5)*(5)*(5))-&gt;75</code>    </p><p>即最后打印出来的结果是75    </p><p>在书写这类宏的时候，要非常注意书写的值，小括号的使用<br><strong>要考虑代码中其替换后的结果</strong><br>要避免失误的情况,一般要参照”带参数的宏的原则”来书写 </p><h3 id="带参数的宏的原则"><a href="#带参数的宏的原则" class="headerlink" title="带参数的宏的原则"></a>带参数的宏的原则</h3><p>一切都要括号<br>整个值最终使用一个括号<br>参数出现的每个地方都有括号  </p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>带参数的宏也可以带多个参数<br>也可以组合&#x2F;嵌套来使用其他宏 </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>带参数的宏在大型程序的代码中使用普遍，可以以空间换取效率<br>宏是没有任何类型检查的<br>部分宏会被inline函数来替代  </p><h2 id="大程序"><a href="#大程序" class="headerlink" title="大程序"></a>大程序</h2><p>一个main()太长了时候分为多个函数<br>一个源代码文件太长了时候分成几个文件    </p><h3 id="项目-多个源文件合一"><a href="#项目-多个源文件合一" class="headerlink" title="项目:多个源文件合一"></a>项目:多个源文件合一</h3><p>我们可以通过<strong>新建项目</strong>的方式，来组合多个源代码来使用  </p><h4 id="新建项目与添加"><a href="#新建项目与添加" class="headerlink" title="新建项目与添加"></a>新建项目与添加</h4><p>我们分别写下两个源文件</p><p>text01.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> ; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span> ; </span><br><span class="line">    <span class="type">int</span> b = <span class="number">6</span> ; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span> , max(a,b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>theMax.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建-项目，如下建立项目<br><img src="https://s3.bmp.ovh/imgs/2022/03/d770cd5787f552f3.png">   </p><p>新建后会自动生成一个<code>main.c</code>视情况使用  </p><p>然后在项目中添加<code>.c</code>文件(即上文两个文件)    </p><p>然后对项目进行编译-运行，即可正常使用   </p><blockquote><p>对于项目，Dev C++的编译会把一共项目中的所有源代码都编译之后，连接起来 </p></blockquote><blockquote><p>有的IDE有分开的编译和构建两个按钮，前者是对单个源代码文件的编译，后者是对整个项目的编译   </p></blockquote><blockquote><p>有一个.c文件是一个编译单元，编译器每次编译只处理一个编译单元  </p></blockquote><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>把<strong>函数原型</strong>放到一个头文件(<code>.h</code>结尾)中，在外面需要调用这个函数的源代码文件(<code>.c</code>文件)的时候<br>外面使用<code>#include &lt;头文件&gt;</code>，如此一来就能让编译器在编译的时候知道函数的原型 </p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>新建一个新的源文件，写入<br><code>int max(int a , int b) ; </code><br>随后命名为<code>theMax.h</code>,此时的<code>test01</code>即可修改为   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;theMax.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span> ; </span><br><span class="line">    <span class="type">int</span> b = <span class="number">6</span> ; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span> , max(a,b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成功    </p><h4 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">它的作用是，**把对应文件的全部文本内容原封不动地插入到它在的地方**  </span><br><span class="line">所以，也不一定要在```.c```文件的最开头写下```#include &lt;&gt;```   </span><br><span class="line"></span><br><span class="line">##### 使用形式</span><br><span class="line">使用``` &quot;&quot; ```或者 ```&lt;&gt;``` 来指出要插入的文件  </span><br><span class="line">``` &quot;&quot; ``` 要求编译器首先在当前目录寻找这个文件，若没有，再去编译器指定的目录寻找   </span><br><span class="line">```&lt;&gt;```  让编译器只在指定的目录寻找</span><br><span class="line"></span><br><span class="line">&gt; 编译器知道自己的标准库的头文件在哪里</span><br><span class="line">&gt; 环境变量和编页码命令行参数也能指定寻找头文件的目录    </span><br><span class="line"></span><br><span class="line">\#include并非是引入库的，它只做插入 </span><br><span class="line">现在的C语言编译器默认会引入所有标准库   </span><br><span class="line">例如```#include &lt;stdio.h&gt;```是为了让编译器知道```printf```函数的原型，来保证你调用时给出的参数值是正确的类型    </span><br><span class="line"></span><br><span class="line">在使用和定义某个函数的地方都应该\#include这个头文件 </span><br><span class="line">&gt; 一般的做法就是任何.c都有对应的同名.h文件，把所有对外公开的函数的原型和全局变量的声明都放进去  </span><br><span class="line"></span><br><span class="line">&gt; 全局变量，也是可以在多个.c中共享的</span><br><span class="line"></span><br><span class="line">#### static </span><br><span class="line">在函数前面加上```static```就使得它成为只能在所在编译单元中被使用的函数  </span><br><span class="line">在全局变量前面加上```static```参数就可以使得它成为只能在所在的编译单元中被使用的全局变量    </span><br><span class="line"></span><br><span class="line">## 声明</span><br><span class="line">需要有一个**声明**来表示项目的某处有某个变量    </span><br><span class="line"></span><br><span class="line">### 声明全局变量    </span><br><span class="line">使用```extern```关键字来表示“在某个位置，会有这么一个全局变量”  </span><br><span class="line">比如如下修改刚才的三个文件: </span><br><span class="line"></span><br><span class="line">test01:</span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;theMax.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int a = 5 ; </span><br><span class="line">    int b = 6 ; </span><br><span class="line">    printf(&quot;%d \n&quot; , max(a,gALL)); //将b改成了gALL这个全局变量</span><br><span class="line"></span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>theMax.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;theMax.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gALL = <span class="number">12</span> ;<span class="comment">//这里加入了一个全局变量gALL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>theMax.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> ; </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> gAll ; <span class="comment">//使用extern关键字     </span></span><br></pre></td></tr></table></figure><h3 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h3><p>在C语言中，定义与声明是两个不同的东西</p><figure class="highlight plaintext"><figcaption><span>i ; ```是变量的定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">```extern int i  ; ```是变量的声明  </span><br><span class="line"></span><br><span class="line">定义是产生代码的东西    </span><br><span class="line">&gt; 函数，全局变量    </span><br><span class="line"></span><br><span class="line">声明是不产生代码的东西  </span><br><span class="line">&gt; 比如 函数原型，变量声明，结果声明，宏声明，枚举声明，类型声明，inline函数 </span><br><span class="line"></span><br><span class="line">只有声明可以被放到头文件中  </span><br><span class="line">&gt; 是一个默认的规则，在头文件中进行定义容易出错  </span><br><span class="line"></span><br><span class="line">在头文件中定义很容易造成一个项目中多个编译单元里有重名的实体    </span><br><span class="line"></span><br><span class="line">&gt; 某些编译器允许几个编译单元中存在同名的函数，或者用weak修饰符来强调这些存在    </span><br><span class="line"></span><br><span class="line">同一个编译单元，同名的结构不能被重复声明    </span><br><span class="line">利用标准头文件，可以防止这种情况发生    </span><br><span class="line"></span><br><span class="line">#### 标准头文件</span><br></pre></td></tr></table></figure><p>#ifndef XXX<br>#define XXX<br>…<br>…</p><p>#endif</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```#ifndef XXX```:如果没有定义过XXX</span><br><span class="line"></span><br><span class="line">&gt; 运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次    </span><br><span class="line">&gt; #program once 也能起到相同的作用，但并非所有编译器都支持  </span><br><span class="line"></span><br><span class="line">## 格式化输入输出</span><br><span class="line">我们之前在```printf```和```scanf```中曾经设法规定其输入输出形式，实际上即   </span><br><span class="line"></span><br><span class="line">***printf** </span><br><span class="line">```%[flags][width][.prec][hlL]type```   </span><br><span class="line"></span><br><span class="line">**scanf**   </span><br><span class="line">```%[flag]type```   </span><br><span class="line"></span><br><span class="line">### printf</span><br><span class="line">```%[flags][width][.prec][hlL]type```   </span><br><span class="line">使用```[flags]```，有以下可填:    </span><br><span class="line">```-```:左对齐。不加就是右对齐  </span><br><span class="line">```+```:在前面放+或-，强制输出加号      </span><br><span class="line">```(space)```:整数留空  </span><br><span class="line">```0```:0填充   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用```[width]以及[.prec]```，可填: </span><br><span class="line">```&lt;数字&gt;```:最小字符数，整个输出占据的位置 </span><br><span class="line">``` * ```:下一个参数是字符数    </span><br><span class="line">```.&lt;数字&gt;```:小数点之后的位数  </span><br><span class="line">``` .* ```:下一个参数是小数点后的位数   </span><br><span class="line">比如</span><br><span class="line">9.2f:一共占据九个位置，其中小数点后占据两个位置 </span><br><span class="line">```printf(&quot;%*d \n&quot;,6,123) ; ``` 一共有**6**位字符，值为**123**也就是说第一位参数规定了这个地方的输入数目      </span><br><span class="line"></span><br><span class="line">使用```[hlL]```来进行修饰，可填:    </span><br><span class="line">```hh```:单个字节   </span><br><span class="line">```h```: short  </span><br><span class="line">```l```:long    </span><br><span class="line">```ll```:long long  </span><br><span class="line">```L```:long double </span><br><span class="line"></span><br><span class="line">#### type类型(printf)   </span><br><span class="line">这部分比较多，因此单独列出  </span><br><span class="line">i/d :用于int    </span><br><span class="line">u : unsigned int </span><br><span class="line">o:八进制    </span><br><span class="line">x:十六进制  </span><br><span class="line">X：字母大写的十六进制   </span><br><span class="line">f/F:float,6 </span><br><span class="line">e/E:指数    </span><br><span class="line">g/G:float   </span><br><span class="line">a/A:十六进制浮点数  </span><br><span class="line">c:char  </span><br><span class="line">s:字符串    </span><br><span class="line">p:指针  </span><br><span class="line">n:读入/写入的个数   </span><br><span class="line"></span><br><span class="line">### scanf   </span><br><span class="line">使用```[flags]```，有以下可填:    </span><br><span class="line">``` * ```:跳过  </span><br><span class="line">``` &lt;数字&gt; ```：最大字符数  </span><br><span class="line">``` hh ```: char    </span><br><span class="line">``` h ``` : short   </span><br><span class="line">``` l ``` : long/double </span><br><span class="line">``` ll ```：long long   </span><br><span class="line">``` L ``` :long double  </span><br><span class="line"></span><br><span class="line">#### type类型(scanf)    </span><br><span class="line">d : int </span><br><span class="line">i ：整数，可能为十六进制，可能为八进制 </span><br><span class="line">u : unsigned int    </span><br><span class="line">o ：八进制  </span><br><span class="line">x ：十六进制    </span><br><span class="line">a,e,f,g: float  </span><br><span class="line">c : char    </span><br><span class="line">s : 字符串(单词)   </span><br><span class="line">p : 指针 </span><br><span class="line">[...] :所允许的字符 </span><br><span class="line"></span><br><span class="line">### printf和scanf的返回值   </span><br><span class="line">printf:读入的项目处 </span><br><span class="line">scanf:输出的字符数  </span><br><span class="line"></span><br><span class="line">&gt; 在要求严格的程序中，应该判断每次调用scanf或printf的返回值，从而了解程序运行中是否存在问题 </span><br><span class="line"></span><br><span class="line">## 文件输入输出 </span><br><span class="line"></span><br><span class="line">### 重定向: 输入&lt;  ,  输出&gt;    </span><br><span class="line">在终端，可以利用```&gt;``` 和 ```&lt;``` 作重定向输入输出 </span><br><span class="line">不过一般情况还是使用```FILE```来进行重定向  </span><br><span class="line"></span><br><span class="line">### FILE    </span><br><span class="line">```FILE* fopen(const char* restrict path , const char* restrict mode);```   </span><br><span class="line">```int fclose(FILE *stream);```</span><br><span class="line">```fscanf(FILE* , ...)``` </span><br><span class="line">```fprintf(FILE*,...)```  </span><br><span class="line"></span><br><span class="line">#### 打开文件的标准代码 </span><br><span class="line">```C</span><br><span class="line">FILE* fp = fopen(&quot;file&quot; , &quot;r&quot;);  //第一个参数是文件名，第二个参数是表明我们打开它是为了读</span><br><span class="line"></span><br><span class="line">if(fp) &#123; //判断是否成功打开</span><br><span class="line">    fscanf(fp,...) ; //第一个参数是指向代表文件的指针，后面的参数同scanf    </span><br><span class="line">    fclose(fp) ;  //关闭</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fopen的第二个参数</strong><br>r:打开，只读<br>r+:打开读写，从文件头开始<br>w:打开，只写。若不存在则新建，若存在则清空<br>w+:打开读写。若不存在则新建，若存在则清空<br>a:打开追加。若不存在则新建，若存在则从文件尾开始<br>..x:在上述符号的后面可以加上该符号。只新建，如果文件已存在则不能打开(一般加在w&#x2F;a后面，可以避免对已有的文件可能的破坏)    </p><h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>所有文件的最终都是二进制文件<br>二进制文件是需要专门的程序去读写的文件<br>文本文件的输入输出是格式化，可能经过转码    </p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Unix喜欢使用文本文件夹来做数据存储和程序配置，交互式终端的出现使得人们喜欢用文本和计算机来交互<br>Unix的shell提供了一些读写文本的小程序   </p><p>而windows喜欢用二进制文件，PC刚开始的时候能力有限，DOS的能力更有限<br>二进制更接近底层    </p><p>文本：<br>方便人类读写、跨平台<br>程序的输入输出要经过格式化，开销大  </p><p>二进制：<br>人类读写困难，不跨平台(比如int大小不一致)<br>优点是程序读写快    </p><h4 id="程序与文件"><a href="#程序与文件" class="headerlink" title="程序与文件"></a>程序与文件</h4><p>配置：Unix使用文本，windows使用注册表(一个非常大的二进制文件)<br>数据：稍微比较有点量的数据均放在数据库中<br>媒体：只能是二进制的    </p><blockquote><p>事实上，程序通过第三方库来读写文件，很少直接读写二进制文件了  </p></blockquote><h3 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h3><p>二进制读<br><code>size_t fread(void *restrict ptr , size_t size, size_t nitems , FILE *restrict stream) ;</code></p><p>二进制写<br><code>size_t fwrite(const void *restrict ptr , size_t size,size_t nitems , FILE* restrict stream)</code></p><p>第一个参数是要读写的内存，第二个参数是这块内存的大小，第三个参数是有多少个这样的内存，最后一个参数是文件指针<br>返回的是成功读写的字节数    </p><blockquote><p>对二进制文件的读写一般是通过对一个结构变量的操作来进行的,nitem用来说明这次读写的几个结构变量  </p></blockquote><h3 id="在二进制文件中定位"><a href="#在二进制文件中定位" class="headerlink" title="在二进制文件中定位"></a>在二进制文件中定位</h3><p><code>long ftell(FILE *stream) ; </code><br><code>int fseek(FILE *stream , long offest , int whence);</code>   </p><p>SEEK_SET:从头开始<br>SEEK_CUR:从当前位置开始<br>SEEK_END:从尾开始(倒着来)   </p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>在这种情况下写出的文本不具有可移植性    </p><blockquote><p>比如在int为32位的机器上写成的数据文件，就无法在int为64位的机器上正确读出  </p></blockquote><p>解决方案之一是放弃int,而是使用<code>typedef</code>具有明确大小的类型<br>更好的方案是使用文本    </p><h2 id="换位运算"><a href="#换位运算" class="headerlink" title="换位运算"></a>换位运算</h2><h3 id="换位运算符"><a href="#换位运算符" class="headerlink" title="换位运算符"></a>换位运算符</h3><p>C语言有这些按位运算符   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">```|```：按位的或   </span><br><span class="line">```~```：按位的取反 </span><br><span class="line">```^```：按位的异或 </span><br><span class="line">```&lt;&lt;```：左移</span><br><span class="line">```&gt;&gt;```：右移  </span><br><span class="line">下文若无特殊表述，均是位运算    </span><br><span class="line"></span><br><span class="line">#### 按位与</span><br><span class="line">若```x==1,y==1```,(x&amp;y) = 1 ; 否则(x&amp;y) = 0   </span><br><span class="line">常被用于两种应用:</span><br><span class="line">1.让某一位或某些位为0，如: x &amp; 0xFE  </span><br><span class="line">&gt; FE:1111 1110，它可以使得某一个数的最低位变成0  </span><br><span class="line">2.取某一个数中的一段: x &amp; 0xFF  </span><br><span class="line">&gt; FF:1111 1111,使和FE进行按位与的部分皆被保存     </span><br><span class="line"></span><br><span class="line">#### 按位或</span><br><span class="line">若```x==1```,或```y==1```，那么就有(x|y) = 1 , 否则才有(x|y) = 0    </span><br><span class="line">常被用于两种应用:   </span><br><span class="line">1.使得一位或者几个位为1，如：x | 0x01   </span><br><span class="line">2.把两个数相拼接，如: 0X00FF | 0XFF00 ,结果就是0XFFFF   </span><br><span class="line"></span><br><span class="line">#### 按位取反    </span><br><span class="line">把1位变成0，0位变成1    </span><br><span class="line">想要得到全部位为1的数，使用```~0``` </span><br><span class="line"></span><br><span class="line">#### 按位异或</span><br><span class="line">在C中，没有表示幂次的运算符，```^```表示按位异或    </span><br><span class="line">若```x==y```,那么有(x^y) = 0  </span><br><span class="line">否则，(x^y) = 1</span><br><span class="line">&gt; 如果两个位相等，结果为0；不相等，结果为1  </span><br><span class="line"></span><br><span class="line">&gt; 对同一个变量，连续使用另一个相同的变量连续异或两次，则等于没做    </span><br><span class="line"></span><br><span class="line">&gt; 上述那一条可以做一个非常非常弱的加密运算↑</span><br><span class="line"></span><br><span class="line">### 逻辑运算与按位运算  </span><br><span class="line">在逻辑运算中，实质上它只看到两个值：0和1    </span><br><span class="line">可以认为逻辑运算相当于把所有非0值都变成1，然后做按位运算    </span><br><span class="line">5&amp;4 -&gt;4</span><br><span class="line">5&amp;&amp;4 -&gt; 1&amp;1 -&gt;1</span><br><span class="line">&gt;实际上，在计算机中，我们只有按位运算，而没有逻辑运算   </span><br><span class="line"></span><br><span class="line">## 移位运算 </span><br><span class="line"></span><br><span class="line">### 左移    </span><br><span class="line">i &lt;&lt; j </span><br><span class="line">把i中所有的为都向左移动j个位置，而右边填入0     </span><br><span class="line">所有小于int的类型，移位使用int的方式来做，结果也是int   </span><br><span class="line">$x &lt;&lt;= 1$ 等价于 $x *= 2 $  (&lt;&lt;=表示&lt;&lt;1 后的结果，类比x+=2这种形式)    </span><br><span class="line">$x &lt;&lt;= n$ 等价于 $x *= 2^n$ </span><br><span class="line">对于二进制而言,左移了一位自然是等价于数值的翻倍</span><br><span class="line"></span><br><span class="line">### 右移</span><br><span class="line">i &gt;&gt; j </span><br><span class="line">i中所有的位向右移j位    </span><br><span class="line">所有小于int的类型，移位以int的方式来做，结果是int   </span><br><span class="line">对于```unsigned```类型，左边填入0   </span><br><span class="line">对于```signed```类型，左边填入原来的最高位(保持符号不变)    </span><br><span class="line">&gt; 也就是说，此时有符号和无符号是不一样的    </span><br><span class="line"></span><br><span class="line">$x &gt;&gt;= 1$ 等价于 $x /= 2 $      </span><br><span class="line">$x &gt;&gt;= n$ 等价于 $x /= 2^n$ </span><br><span class="line"></span><br><span class="line">另外，移位的位置不要使用负数，这是没有定义的行为    </span><br><span class="line"></span><br><span class="line">## 位运算例子和位段   </span><br><span class="line">&gt; 该部分比较简略，若想了解请参考翁恺老师的13.2-3位运算例子和12.2-4位段    </span><br><span class="line">&gt; 或者，直接刷相关的题目，能更好地理解  </span><br><span class="line"></span><br><span class="line">例子:输出一个数的二进制 </span><br><span class="line">```C</span><br><span class="line">#include &lt;stido.h&gt;</span><br><span class="line">int main(int argc , char const *argv[])&#123;</span><br><span class="line">    int number ; </span><br><span class="line">    scanf(&quot;%d&quot; , &amp;number) ; </span><br><span class="line">    unsigned mask = lu&lt;&lt;31 ; </span><br><span class="line"></span><br><span class="line">    for( ; mask ; mask &gt;&gt;=1 )&#123;</span><br><span class="line">        printf(&quot;%d&quot; ， number &amp;mask?1:0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;) ; </span><br><span class="line"></span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把一个int的若干位都合成一个结构     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> leading : <span class="number">3</span> ; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> FLAG1: <span class="number">1</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> FLAG2: <span class="number">2</span> ;</span><br><span class="line">    <span class="type">int</span> trailing: <span class="number">11</span> ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个成员的后面，有一个<code>:</code>,其后面的数字表示一个成员占几个比特  </p><p>定义位段之后，可以用位段的成员名称来访问<br>比移位、与、或还方便<br>编译器会安排其中位的排列，不具有可移植性<br>当所需的位超过一个int时候会采用多个int  </p><h2 id="制作可变数组"><a href="#制作可变数组" class="headerlink" title="制作可变数组"></a>制作可变数组</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>我们先如下考虑，我们需要这些函数来实现我们的要求：</p><figure class="highlight plaintext"><figcaption><span>array_create(int init_size);``` 创建这个数组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```void array_free(Array *a);``` 回收数组空间    </span><br><span class="line">```int array_size(const Array *a);```得到数组大小   </span><br><span class="line">```int* array_at(Array *a , int index);```获得某个单元、可读可写  </span><br><span class="line">```void array_inflate(Array *a , int more_size);```让数组扩大 </span><br><span class="line"></span><br><span class="line">### 基础    </span><br><span class="line">首先定义一个结构表示该数组  </span><br><span class="line">创建```array.h```:  </span><br><span class="line">```c</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int *array ; </span><br><span class="line">    int size ;</span><br><span class="line">&#125; Array;</span><br></pre></td></tr></table></figure><p>按照要求定义整体头文件如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ARRAY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ARRAY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> ; </span><br><span class="line">    <span class="type">int</span> size ;</span><br><span class="line">&#125; Array;</span><br><span class="line"></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span>;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a , <span class="type">int</span> index)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a , <span class="type">int</span> more_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>随后使用一个<code>array.c</code>来进行函数的实现   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">```c</span><br><span class="line">#include &quot;array.h&quot;</span><br><span class="line"></span><br><span class="line">// typedef struct &#123;</span><br><span class="line">//     int *array ; </span><br><span class="line">//     int size ;</span><br><span class="line">// &#125; Array;</span><br><span class="line"></span><br><span class="line">Array array_create(int init_size)&#123;</span><br><span class="line">    Array a ;</span><br><span class="line">    a.size = init_size ; //通过输入的值来确定大小</span><br><span class="line">    a.array = (int*)malloc(sizeof(int)*a.size) ; //根据大小来分配空间</span><br><span class="line">    return a ; //注意，返回的是a本身而非指针</span><br><span class="line">    //事关本地变量、指针的周期等等，若返回指针会导致失效</span><br><span class="line">    //这一部分可以再看看指针那一块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void array_free(Array *a)&#123;</span><br><span class="line">    //做两件事情，释放对应的空间+保险起见把size改为0</span><br><span class="line">    free(a-&gt;array) ;</span><br><span class="line">    a-&gt;array = NULL ; </span><br><span class="line">    a-&gt;size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int array_size(const Array *a);</span><br><span class="line">int* array_at(Array *a , int index); </span><br><span class="line">void array_inflate(Array *a , int more_size);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="可变数组的数据与访问"><a href="#可变数组的数据与访问" class="headerlink" title="可变数组的数据与访问"></a>可变数组的数据与访问</h3><p>对于<strong>得到数组大小</strong>这件事，我们实际上由两种做法<br>一是直接得到，也就是说<code>a.size</code><br>第二种就是我们下面要做的，也就是<strong>封装</strong>，这样可以保护<code>a.size</code>  </p><p>书接上文:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;array.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct &#123;</span></span><br><span class="line"><span class="comment">//     int *array ; </span></span><br><span class="line"><span class="comment">//     int size ;</span></span><br><span class="line"><span class="comment">// &#125; Array;</span></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;size ; <span class="comment">//通过指针来访问到该数组，随后得到size</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a , <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">//注意，这里拿的返回值是一个指针    </span></span><br><span class="line">    <span class="keyword">return</span> &amp;(a-&gt;<span class="built_in">array</span>[index]);</span><br><span class="line">    <span class="comment">//为什么返回指针:因为如果返回的是指针，可以方便赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当然，类似的，我们还可以写下以下类似的方法:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_get</span><span class="params">(<span class="type">const</span> Array*a , <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;<span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_set</span><span class="params">(Array *a , <span class="type">int</span> index , <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">array</span>[index] = value ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用两个分别的get和set，达到了目的  </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a , <span class="type">int</span> more_size)</span>;</span><br></pre></td></tr></table></figure><h3 id="可变数组自动增长"><a href="#可变数组自动增长" class="headerlink" title="可变数组自动增长"></a>可变数组自动增长</h3><p>来到了最重要的部分了<br>逻辑是：重新申请一块新的空间，该空间大小是<strong>旧空间+新空间</strong>：<br><code>int *p = (int\*)malloc(sizeof(int)(a-&gt;size + more_size)); </code><br>接下来，我们需要利用循环来把旧的内容赋值到新的空间去：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i ; </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; (a-&gt;size) ; i++)&#123;</span><br><span class="line">    p[i] = a-&gt;<span class="built_in">array</span>[i] ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是最终的处理，释放空间+转移：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>) ; </span><br><span class="line">a-&gt;<span class="built_in">array</span> = p ;</span><br><span class="line">a-&gt;size += more_size ;</span><br></pre></td></tr></table></figure><p>最终的函数如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a , <span class="type">int</span> more_size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>\*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)(a-&gt;size + more_size));</span><br><span class="line">    <span class="type">int</span> i ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; (a-&gt;size) ; i++)&#123;</span><br><span class="line">        p[i] = a-&gt;<span class="built_in">array</span>[i] ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>) ; </span><br><span class="line">    a-&gt;<span class="built_in">array</span> = p ;</span><br><span class="line">    a-&gt;size += more_size ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般是在进行<code>array_at</code>的时候会检测是否越界<br>那么我们在此处加入判断并中需要的时候加入自动增长    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a , <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= a-&gt;size)&#123;</span><br><span class="line">        array_inflate(a,index-(a-&gt;size)+<span class="number">1</span>); <span class="comment">//这样子是刚刚好会增长一位</span></span><br><span class="line">        <span class="comment">//当然，我们也可以引入block的概念，每次需要的时候增长x位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.hs&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;array.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct &#123;</span></span><br><span class="line"><span class="comment">//     int *array ; </span></span><br><span class="line"><span class="comment">//     int size ;</span></span><br><span class="line"><span class="comment">// &#125; Array;</span></span><br><span class="line"></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span>&#123;</span><br><span class="line">    Array a ;</span><br><span class="line">    a.size = init_size ; <span class="comment">//通过输入的值来确定大小</span></span><br><span class="line">    a.<span class="built_in">array</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*a.size) ; <span class="comment">//根据大小来分配空间</span></span><br><span class="line">    <span class="keyword">return</span> a ; <span class="comment">//注意，返回的是a本身而非指针</span></span><br><span class="line">    <span class="comment">//事关本地变量、指针的周期等等，若返回指针会导致失效</span></span><br><span class="line">    <span class="comment">//这一部分可以再看看指针那一块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span>&#123;</span><br><span class="line">    <span class="comment">//做两件事情，释放对应的空间+保险起见把size改为0</span></span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>) ;</span><br><span class="line">    a-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span> ; </span><br><span class="line">    a-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;size ; <span class="comment">//通过指针来访问到该数组，随后得到size</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a , <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= a-&gt;size)&#123;</span><br><span class="line">        array_inflate(a,index-(a-&gt;size)+<span class="number">1</span>); <span class="comment">//这样子是刚刚好会增长一位</span></span><br><span class="line">        <span class="comment">//当然，我们也可以引入block的概念，每次需要的时候增长x位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当然，类似的，我们还可以写下以下类似的方法:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_get</span><span class="params">(<span class="type">const</span> Array*a , <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;<span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_set</span><span class="params">(Array *a , <span class="type">int</span> index , <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">array</span>[index] = value ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用两个分别的get和set，达到了目的 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a , <span class="type">int</span> more_size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>\*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)(a-&gt;size + more_size));</span><br><span class="line">    <span class="type">int</span> i ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; (a-&gt;size) ; i++)&#123;</span><br><span class="line">        p[i] = a-&gt;<span class="built_in">array</span>[i] ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>) ; </span><br><span class="line">    a-&gt;<span class="built_in">array</span> = p ;</span><br><span class="line">    a-&gt;size += more_size ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可变数组的缺陷"><a href="#可变数组的缺陷" class="headerlink" title="可变数组的缺陷"></a>可变数组的缺陷</h2><p>有两个比较重要的缺陷：<br>1.每次在扩增的时候都有一个copy的过程，随着数据的增多，这部分的开销就会越来越大<br>2.可能在在内存还足够的时候发生申请空间失败的情况<br>如果将想法改为<strong>不拷贝，但是链接各个部分</strong>来进行扩增，就可以避免这种情况，那就是<strong>链表</strong></p><h2 id="实现链表"><a href="#实现链表" class="headerlink" title="实现链表"></a>实现链表</h2><p>该部分算比较基础的数据结构了</p><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>把一块单元分为两个部分，第一个部分是该数据，第二部分是指针(该指针指向下一位)    </p><blockquote><p>一个“这样的单元”被称为“结点”<br>在最后一个数据，其指针指向“结束”<br>同时，还需要一个指针指向该链表的头  </p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先是这样的结构    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _NODE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NODE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> value ; s</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span> ;</span> </span><br><span class="line">    <span class="comment">// 不能在这李写 Node *next ; 因为此时&quot;Node&quot;还没出现 </span></span><br><span class="line">&#125;Node ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>最开始的部分，指向我们的第一个数据的指针 ,p,需要手动得出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node *p = (Node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)) ; </span><br><span class="line">p-&gt;value = number ; <span class="comment">//这里的number是一个传进来的值  </span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span> ; <span class="comment">//目前这个链表就一个数据，因此p既是头也是尾,next指向NULL</span></span><br></pre></td></tr></table></figure><p>那么我们想添加一个值该如何处理呢，首先应该先找到当前的最后一个指针  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node *last = head ; <span class="comment">//这里=head一是为了初始化，二是那些只有一个元素的情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">    <span class="comment">//(last-&gt;next)的意思是当last-&gt;next有东西，即不为NULL的时候，就一直执行</span></span><br><span class="line">    last = last-&gt;next ; <span class="comment">//不断更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是增加新的数据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node *q = (Node*) malloc(sizeof(Node)) ; </span><br><span class="line">q-&gt;value = number ; //这里的number是一个传进来的值  </span><br><span class="line">q-&gt;next = NULL ; </span><br><span class="line"></span><br><span class="line">last-&gt;next = p ;</span><br></pre></td></tr></table></figure><h4 id="last是NULL的情况"><a href="#last是NULL的情况" class="headerlink" title="last是NULL的情况"></a>last是NULL的情况</h4><p>如果last &#x3D;&#x3D; NULL,则代码的执行会出现问题。所有最终，添加一个元素&#x2F;新建一个链表的操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)) ; </span><br><span class="line">p-&gt;value = number ; </span><br><span class="line">p-&gt;next = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找last</span></span><br><span class="line">Node *last = head ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(last)&#123;</span><br><span class="line">    <span class="keyword">while</span>(last -&gt; next) &#123;</span><br><span class="line">        last = last-&gt;next ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    last-&gt;next = p</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="comment">//如果p是第一个元素，此时要让p被加到head指向的地方，而非last指向的地方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="链表的函数"><a href="#链表的函数" class="headerlink" title="链表的函数"></a>链表的函数</h2><h3 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h3><p>首先把之前的操作变成一个函数</p><p>注意一个问题:</p><blockquote><p>子函数访问的是地址，并且修改的地址指向的值(指针指向的值)，而不是修改地址<br>函数传递传值，是互不影响的，因此在子函数改地址，是影响不到主函数的<br>但现在的情况就是，我们要改的不是地址的值————我们要改的是地址</p></blockquote><p>我们先抄一下之前的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(Node* head , <span class="type">int</span> number)</span>&#123;</span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)) ; </span><br><span class="line">    p-&gt;value = number ; </span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找last</span></span><br><span class="line">    Node *last = head ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(last)&#123;</span><br><span class="line">        <span class="keyword">while</span>(last -&gt; next) &#123;</span><br><span class="line">            last = last-&gt;next ; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        last-&gt;next = p</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head = p;</span><br><span class="line">        <span class="comment">//如果p是第一个元素，此时要让p被加到head指向的地方，而非last指向的地方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>别使用全局变量的方法，那会使链表只能产生一个且是不安全的  </p></blockquote><p>其中一个方法是，让函数返回一个Node*，并在增加函数的地方使得<code>head = add(head,numer)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">add</span><span class="params">(Node\* head ,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">head = add(head,number);</span><br></pre></td></tr></table></figure><p>但是有一个缺点:必须仔细地使用，不要忘记了<code>head = add(head,number);</code>否则就会有问题出现   </p><h3 id="增加List"><a href="#增加List" class="headerlink" title="增加List"></a>增加List</h3><p>解决上面出现的问题，不妨再定义一个东西<code>List</code>使得表和结点分开    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span>&#123;</span></span><br><span class="line">    Node* ; </span><br><span class="line">&#125;List ;</span><br></pre></td></tr></table></figure><p>然后在函数中，传入List的指针，然后对List做修改  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List* pLiast , <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)) ; </span><br><span class="line">    p-&gt;value = number ; </span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找last</span></span><br><span class="line">    Node *last = pList -&gt;head ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(last)&#123;</span><br><span class="line">        <span class="keyword">while</span>(last -&gt; next) &#123;</span><br><span class="line">            last = last-&gt;next ; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        last-&gt;next = p</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pList-&gt;head = p;</span><br><span class="line">        <span class="comment">//如果p是第一个元素，此时要让p被加到head指向的地方，而非last指向的地方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们在主函数的操作也需要做出对应修改  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    List <span class="built_in">list</span> ;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span> ;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;number) ;</span><br><span class="line">        <span class="keyword">if</span>(number != <span class="number">-1</span>)&#123;</span><br><span class="line">            add(&amp;<span class="built_in">list</span>,number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>( number != <span class="number">-1</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处在于，现在使用了自己定义的结构List定义了<strong>整个链表</strong>    </p><p>我们还可以以此为基础扩展，比如我们现在想要List包含尾部，这样我们就不用一直遍历了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span>&#123;</span></span><br><span class="line">    Node* head ; </span><br><span class="line">    Node* tail ; </span><br><span class="line">&#125; List ;</span><br></pre></td></tr></table></figure><p>相关的地方也需要修改，这里就不演示了    </p><h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>首先，在C语言中，如果我们想要遍历链表，可以使用:    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(List *pList)</span>&#123;</span><br><span class="line">    Node *p ; </span><br><span class="line">    <span class="keyword">for</span>(p = plist-&gt;head ; p; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t&quot;</span>,p-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果想要加入搜索相关的组件，就只需要把搜索值的判断加入进去即可    </p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除主要做两件事情：<br>1.把要删除的指针的前一位指针，指向要删除的指针的后一位<br>2.释放空间</p><p>我们利用一个额外的变量<code>Node *q</code>来进行层层推进，知道找到目标<br>然后进行要做的两步操作：    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node *q ; </span><br><span class="line">Node *p ; </span><br><span class="line"><span class="keyword">for</span>(q =<span class="literal">NULL</span>,p=<span class="built_in">list</span>.head ; p ; q=p,p=p-&gt;next)&#123;</span><br><span class="line">    <span class="comment">//每一步都使得q=p,p=p-&gt;next来逐步前推</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( p-&gt;value == number)&#123;</span><br><span class="line">        <span class="comment">//number是我们要删除的那个数</span></span><br><span class="line">        <span class="keyword">if</span>(q)&#123;</span><br><span class="line">            q-&gt;next = p-&gt;next ; </span><br><span class="line">            <span class="comment">//如果存在q,也是就是第一次执行或者改链表仅有一位元素    </span></span><br><span class="line">            <span class="comment">//那么想删除该元素，只需要把q的下一位连p的下一位</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">list</span>.head = p-&gt;next ; </span><br><span class="line">            <span class="comment">//否则就照常进行改动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p) ; <span class="comment">//都完成之后把p的空间释放 </span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表清除"><a href="#链表清除" class="headerlink" title="链表清除"></a>链表清除</h3><p>在必要的时候，我们需要把整个链表清除干净<br>一步步的把每一个结点的“下一个结点的指针”清除即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( p=head ; p ; p=q)&#123;</span><br><span class="line">    q = p-&gt;next ; </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>14的这一部分主要还是看看，更多关键的实现和想法，还需要参照算法、数据结构的相关要求</p>]]></content>
    
    
    <summary type="html">附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【基础C语言】六、枚举,结构,类型</title>
    <link href="http://example.com/2022/03/08/%E5%85%AD%E3%80%81%E6%9E%9A%E4%B8%BE%EF%BC%8C%E7%BB%93%E6%9E%84%EF%BC%8C%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2022/03/08/%E5%85%AD%E3%80%81%E6%9E%9A%E4%B8%BE%EF%BC%8C%E7%BB%93%E6%9E%84%EF%BC%8C%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-03-08T03:00:00.000Z</published>
    <updated>2022-03-08T16:48:15.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、枚举-x2F-结构-x2F-类型"><a href="#六、枚举-x2F-结构-x2F-类型" class="headerlink" title="六、枚举&#x2F;结构&#x2F;类型"></a>六、枚举&#x2F;结构&#x2F;类型</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>使用enum结构来定义一个枚举，下标由0开始<br><code>enum COLOR &#123;RED,YELLOW,GREEN&#125;;</code><br>上述定义了一个名叫COLOR的枚举，其中RED&#x3D;0,YELLOW&#x3D;1.GREEN&#x3D;2   </p><blockquote><p>枚举是一种用户定义的数据类型，它用关键字enum来声明<br>其语法为:<br>enum &lt;枚举类型名字&gt; {&lt;名字0&gt;,&lt;名字1&gt;…&lt;名字n&gt;} ; </p></blockquote><p>比较重要的是大括号中的名字，它们实际上就是常量符号，类型为int，下标值从0到n </p><p>枚举量可以作为值，但是实际上是以整数来做内部计算和外部输入输出的    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span>red,yellow,green&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">enum</span> color c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">t</span> =</span> red ; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;t) ; </span><br><span class="line">    f(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">enum</span> color c)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>  , c) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="套路：计数"><a href="#套路：计数" class="headerlink" title="套路：计数"></a>套路：计数</h4><p>可以在枚举的最后采用一个<code>NumXXX</code>来辅助计数  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">```enum COLOR &#123;RED,YELLOW,GREEN,NumColor&#125; ; ```</span><br><span class="line">这里NumColor = 3 ; </span><br><span class="line"></span><br><span class="line">#### 指定值</span><br><span class="line">我们可以指定枚举对应的int，比如:    </span><br><span class="line">```enum COLOR &#123;RED = 1 , YELLOW , GREEN = 5&#125;;```    </span><br><span class="line">1.没有声明时，改位默认位前位+1  </span><br><span class="line">2.数值可以是离散的  </span><br><span class="line">比如此时RED=1，没有指定YELLOW的值，则YELLOW=2   </span><br><span class="line">而指定了GREEN = 5 ,则其是不连续的，GREEN = 5而非3   </span><br><span class="line"></span><br><span class="line">### 小结</span><br><span class="line">现实中，其实更多把**C**里面的枚举当作辅助定义的符号量   </span><br><span class="line">当作类型使用的时候反而比较少见  </span><br><span class="line">比如有意义上排比的名字，可以用枚举来定义```const int``` </span><br><span class="line">枚举比宏(macro)好，枚举有int类型    </span><br><span class="line"></span><br><span class="line"># 结构  </span><br><span class="line"></span><br><span class="line">## 结构类型 </span><br><span class="line">一个结构是一种复合的数据类型，用许多成员表达**一个变量**    </span><br><span class="line">然后就可以只用该变量来表示这些合在一起的数据    </span><br><span class="line"></span><br><span class="line">### 声明struct</span><br><span class="line">```c</span><br><span class="line">struct date&#123;</span><br><span class="line">    int month ; </span><br><span class="line">    int day ; </span><br><span class="line">    int year ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct date = today ; </span><br></pre></td></tr></table></figure><p>通常在函数外部声明结构类型，这样它就可以被多个函数所使用    </p><blockquote><p>和本地变量一样，如果在函数内部声明，该结构类型就只能在函数内部使用    </p></blockquote><h4 id="声明结构的形式"><a href="#声明结构的形式" class="headerlink" title="声明结构的形式"></a>声明结构的形式</h4><p>A:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x ; </span><br><span class="line">    <span class="type">int</span> y ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p1</span>,<span class="title">p2</span> ;</span> </span><br></pre></td></tr></table></figure><p>此时p1和p2都是point,里面有x和y的值  </p><p>B:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x ; </span><br><span class="line">    <span class="type">int</span> y ;</span><br><span class="line">&#125; p1,p2 ; </span><br></pre></td></tr></table></figure><p>p1,p2都是无名结构，里面有x和y<br>一般用于暂时使用</p><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x ; </span><br><span class="line">    <span class="type">int</span> y ;</span><br><span class="line">&#125;p1,p2 ; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里p1和p2都是point，里面有x和y的值 </p><p>对于第一种和第三种形式，都声明了结构point<br>第二种形式没有声明point,只是定义了p1,p2两个变量 </p><h4 id="结构变量的使用"><a href="#结构变量的使用" class="headerlink" title="结构变量的使用"></a>结构变量的使用</h4><p>在声明<strong>结构类型</strong>之后可以声明许多属于该类型下的<strong>结构变量</strong>    </p><h5 id="结构初始化"><a href="#结构初始化" class="headerlink" title="结构初始化"></a>结构初始化</h5><p>有两种办法来赋值<br>首先是直接给出对应的n个值   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> &#123;</span></span><br><span class="line">    iint month ; </span><br><span class="line">    <span class="type">int</span> day ; </span><br><span class="line">    <span class="type">int</span> year ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> date <span class="title function_">today</span><span class="params">(<span class="number">01</span>,<span class="number">03</span>,<span class="number">2020</span>)</span> ; </span><br></pre></td></tr></table></figure><p>或者具体指明数值<br><code>struct date thisMonth = &#123;.month = 7 , .year = 2012&#125;</code><br>没给的值就是0   </p><h3 id="结构成员"><a href="#结构成员" class="headerlink" title="结构成员"></a>结构成员</h3><p>使用<code>.</code>运算符来访问成员 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用结构变量的名字来访问整个结构    </span><br><span class="line">对于整个结构，可以做赋值、取地址，可以传递给函数参数    </span><br><span class="line">```c</span><br><span class="line">pl = (struct point)&#123;5,10&#125;  ; //相当于pl.x = 5 ; pl.y = 10 ;</span><br><span class="line">p1 = p2 ; //相当于p1.1 = p2.x ;  p1.y = p2.y ; </span><br></pre></td></tr></table></figure><blockquote><p>和指针&#x2F;数组不一样，做p1&#x3D;p2时，二者是得到了不同的位置，是把p2的值，赋给了p1，而非让p1”指向了”p2的值。二者是独立的  </p></blockquote><h3 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h3><p>和数组不同，结构变量的名字并不是结构变量的地址。<br><strong>因此表示某种结构变量的地址，需要&amp;运算符</strong> </p><h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>结构作用函数参数 <code>int numberOfDay(struct date d)</code>   </p><blockquote><p>整个结构可以作为参数的值传入函数<br>此时是在函数内部新建了一个结构变量，然后去复制调用者的结构的值(本质上传入的还是值)<br>(也就是说它是一个完全不同的、新的结构变量，这和数组是不同的)    </p></blockquote><p>同理，我们也可以返回一个结构    </p><blockquote><p>另外，使用scanf的时候不能一次性scanf来读入结构，得一步步来<br>当我们想要利用函数来返回一个结构体的时候，有两种选择：<br>一，新建一个结构体，接受值。在函数返回时返回该结构体，并在需要它的地方直接使用p1 &#x3D; p2<br>二，利用指针。这是更推荐的方式，因为它消耗的时间和空间都更小(见后文)</p></blockquote><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p><strong>有-&gt;运算符表示指针所指的结构变量中的成员</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> month ; </span><br><span class="line">    <span class="type">int</span> day ; </span><br><span class="line">    <span class="type">int</span> year ; </span><br><span class="line">&#125;myday ; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span> =</span> &amp;myday ; <span class="comment">//这里表示p指针取得myday对应的地址</span></span><br><span class="line"></span><br><span class="line">(*p).month = <span class="number">12</span> ;  </span><br><span class="line"><span class="comment">//p是指针，(*p)表示的则是这个结构体，因此可以直接利用 (*p).month来访问结构成员</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p-&gt;month = <span class="number">12</span> ; </span><br><span class="line"><span class="comment">//p是指针，-&gt;代表p指针所代表的那个结构体中的对应的成员</span></span><br><span class="line"><span class="comment">//-&gt;month即该指针对应的结构体中的month成员</span></span><br></pre></td></tr></table></figure><blockquote><p>-&gt;：Arrow , abc所指的xxx  </p></blockquote><p>和<code>.</code>运算符的操作差不多，可以看作专门用于指针的dot  </p><h2 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h2><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>同其他变量一样，一旦我们声明了某种结构类型，也可以做出其相应的数组  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100] ;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2002</span>&#125;,&#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">2021</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构的结构"><a href="#结构的结构" class="headerlink" title="结构的结构"></a>结构的结构</h3><p>类似的，也可以把结构加入结构中  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dateAndTime</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">sdate</span> ;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">time</span> <span class="title">stime</span> ;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构中的结构的成员的访问是和单层结构相同的<br>也是使用<code>.</code>来进行逐渐访问   </p><p>若有变量定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">r</span> , *<span class="title">rp</span> ;</span> </span><br><span class="line">rp = &amp;r;</span><br></pre></td></tr></table></figure><p>那么以下的四种形式表达的是一样的    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.pt1.x</span><br><span class="line">rp-&gt;pt1.x</span><br><span class="line">(e.pt1).x</span><br><span class="line">(rp-&gt;rt1).x</span><br></pre></td></tr></table></figure><p>注意，不能使用ep-&gt;pt1-&gt;x，因为这里的pt1并不是指针，而是结构体   </p><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><h3 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h3><p>C语言提供了一个叫<code>typedef</code>的功能来声明一个已有的数据类型的新名字<br>比如<code>typedef int Length;</code><br>这样可以使得<strong>Lenghth</strong>成为<strong>int类型</strong>的别名<br>在此之后，Length就可以代替int出现在变量定义和参数声明的地方，如:    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Length a,b,len ; </span><br><span class="line">Length numbers[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>新的名字是某种类型的别名，以此改善了程序的可读性<br><code>typedef &lt;原类型&gt; &lt;新名字&gt; </code>    </p><p>同样的,我们可以利用<code>typeof</code>操作,来为自己创建的结构来定义一个名字,这样就不用每次都打上<code>struct xxx</code>来使用了   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADATEexpale</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> month ; </span><br><span class="line">    <span class="type">int</span> day ; </span><br><span class="line">    <span class="type">int</span> year ;</span><br><span class="line">&#125; Date ; </span><br></pre></td></tr></table></figure><p>在之后即可直接写为<code>Date d = &#123;9,1,2005&#125; ;</code>   </p><p>无论如何，最后的名字才是其别名<br><code>typedef *char[10] Strings ; </code><br>这里<code>Strings</code>就代表一个十个字符串(*char[10])的类型</p><h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>(该部分在目前的学习阶段的情况下很少被用到)</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>存储</strong><br>所有的成员共享一个空间<br>同一时间只有一个成员是有效的<br>union的大小是其最大成员 </p><p><strong>初始化</strong><br>对第一个成员做初始化    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">AnElt</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i ; </span><br><span class="line">    <span class="type">char</span> c ;</span><br><span class="line">&#125;elt1 , elt2 ;</span><br><span class="line"></span><br><span class="line">elt1.i = <span class="number">4</span> ; </span><br><span class="line">elt2. = <span class="string">&#x27;a&#x27;</span> ; </span><br><span class="line">elt2.i = <span class="number">0xEDA23</span> ; </span><br></pre></td></tr></table></figure><p>这时候可以选择那个成员是<code>int i</code>还是 <code>char c</code> 而它们是共用一块内存的 </p>]]></content>
    
    
    <summary type="html">阐述了C语言中基本的枚枚举与结构的使用,类型的定义.以及它们三者与函数,指针的配合</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【基础C语言】五、字符串补充</title>
    <link href="http://example.com/2022/03/08/%E4%BA%94%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A5%E5%85%85/"/>
    <id>http://example.com/2022/03/08/%E4%BA%94%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A5%E5%85%85/</id>
    <published>2022-03-08T02:00:00.000Z</published>
    <updated>2022-03-08T16:48:15.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、字符串补充"><a href="#五、字符串补充" class="headerlink" title="五、字符串补充"></a>五、字符串补充</h1><h2 id="基础补充"><a href="#基础补充" class="headerlink" title="基础补充"></a>基础补充</h2><h3 id="字符数组和字符串"><a href="#字符数组和字符串" class="headerlink" title="字符数组和字符串"></a>字符数组和字符串</h3><p>字符数组和字符串不同，在C语言中二者是不同的</p><p>这是一个字符数组:<code>char word[] = &#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;&#125;</code><br>而这是一个字符串:<code>char word[] = &#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;,&#39;\0&#39;&#125;</code><br>二者的区别在于，我们在初始化该数组的过程中，用一个 <strong>\0</strong> 结尾<br>如此一来，字符串的单元总数会比字符数多一，也就是多了一个0   </p><blockquote><p>字符串是一个”字符数组”，而因为末尾的”\0”，它变成了C语言中的字符串 </p></blockquote><p>字符串以数组的形式存在，以数组或者指针的形式访问(更多时候是以指针的形式)    </p><h4 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h4><p>表达一个变量是字符串，有以下写法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello&quot;</span> ; </span><br><span class="line"><span class="type">char</span> word[] = <span class="string">&quot;Hello&quot;</span> ; </span><br><span class="line"><span class="type">char</span> line[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span> ; </span><br></pre></td></tr></table></figure><p>用双引号括起来的部分，被称为字符串的<strong>字面量</strong><br>两个相连的字符串常量会被自动连起来  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这里是一个例子，&quot;</span></span><br><span class="line">        <span class="string">&quot;相邻的字符串会被自动连接&quot;</span>) ;</span><br></pre></td></tr></table></figure><h2 id="字符串变量-1"><a href="#字符串变量-1" class="headerlink" title="字符串变量"></a>字符串变量</h2><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>当我们定义了两个完全一样的字符串是s1和s2时，它们实际上位于同一地址<br>事实上，s1和s2指向的地方位于程序的<strong>代码段</strong>,而且这一部分的内容都是<strong>只读的</strong><br>也就是说，我们是无法在此修改字符串的    </p><p><code>char* s = &quot;Hello , world!&quot; ; </code><br>此时s是一个指针，其初始化为指向一个字符串常量——而这个常量所在的地方是只读的区域 </p><blockquote><p>实际上s是const char* s ，由于历史原因，编译器接受不带const的写法。但是试图对s指向的字符串做写入则会导致严重后果       </p></blockquote><h4 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h4><p>如果想修改字符串，则应该应用数组来定义<br><code>char s[] = &quot;Hello , world!&quot; ; </code><br>而此时字符串的意义变为”所要的字符串就在此处”，而非char* s 表示的”指向了某个地方的字符串”        </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="type">char</span>* s = <span class="string">&quot;Hello , world!&quot;</span> ; </span><br><span class="line">    <span class="type">char</span> s3 [] = <span class="string">&quot;Hello , world!&quot;</span> ; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;i=%p&quot;</span> , &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = %p \n&quot;</span> , s) ; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3 = %p \n&quot;</span> , s3);</span><br><span class="line"></span><br><span class="line">    s3[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span> ; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This Time, s3[0] = %c \n &quot;</span> , s3[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h4><p>指针： 不知道字符串具体位置，可以处理参数(数组作为参数时是和指针等同的)，可以动态分配空间<br>数组： 字符串就在当前位置，可以动态修改，作为本地变量空间自动被回收   </p><p><strong>如果要处理一个字符串，就用指针</strong><br><strong>如果要构造一个字符串，就用数组</strong>      </p><p>字符串可以表达为<code>char*</code>的形式，而<code>char*</code>不一定是字符串<br>其本意是指向字符串的指针，可能指向的是字符的数组        </p><blockquote><p>只有其所指的字符数组有结尾的0，才能认为它指向的是字符串       </p></blockquote><h2 id="字符串的输入输出"><a href="#字符串的输入输出" class="headerlink" title="字符串的输入输出"></a>字符串的输入输出</h2><h3 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h3><p>字符串的赋值实际上<strong>并没有产生新的字符串</strong>，只是让被赋值的指针指向了对应的区域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *t = <span class="string">&quot;title&quot;</span> ; </span><br><span class="line"><span class="type">char</span> *s ; </span><br><span class="line">s = t ;</span><br></pre></td></tr></table></figure><p>此处并没有产生新的字符串，而只是让指针s指向了t所指的字符串，对s的任何操作都是对t做的    </p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , <span class="built_in">string</span>) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span> , <span class="built_in">string</span>) ; </span><br></pre></td></tr></table></figure><p>scanf会读入一个单词，到<strong>空格,tab,回车为止</strong><br>scanf是不安全的，因为其不知道要读入的内容的长度 </p><p>我们可以在<code>%</code>和<code>s</code>中间限定读取的数量<br><code>scanf(&quot;%7s&quot; , word) ; </code><br>这个数字表示了<strong>最多允许读入的字符的数量</strong>，这个数字应该比数组大小小1，因为字符串数组的末尾固定为0      </p><blockquote><p>另外，在声明字符串的时候，需要初始化为0以免出错     </p></blockquote><p>char buffer[100] &#x3D; “” ; 此时这是一个空字符串，而buffer[0] &#x3D;&#x3D; ‘\0’<br>char buffer[] &#x3D; “” ;  此时这个数组的长度只有1   </p><h2 id="字符串数组与程序参数"><a href="#字符串数组与程序参数" class="headerlink" title="字符串数组与程序参数"></a>字符串数组与程序参数</h2><h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>有两种方式表示字符串数组</p><h4 id="char-X"><a href="#char-X" class="headerlink" title="char[][X]"></a>char[][X]</h4><p>代表的是一个字符串数组，每一个字符串的大小至多为X(有X-1字符)<br>可以认为是把一个个“数组型的字符串”放置到了数组里面，比如<br>a[0] &#x3D;&#x3D; world\0<br>a[1] &#x3D;&#x3D; Hello\0</p><h4 id="char-a"><a href="#char-a" class="headerlink" title="char* a[]"></a>char* a[]</h4><p>表示数组a[]里面存放了各个字符串(的地址)<br>a[0] -&gt;地址1 -&gt;指向”Hello\0”<br>a[1] -&gt;地址2 -&gt;指向”World\0”    </p><p>两种方式是不一样的</p><h3 id="程序参数"><a href="#程序参数" class="headerlink" title="程序参数"></a>程序参数</h3><p>可以作为<code>main</code>函数的参数，比如<br><code>int main(int argc , char const *argv[])</code><br>其中argv[0]是命令本身   </p><blockquote><p>当使用Unix的符号链接时，反映符号链接的名字    </p></blockquote><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="putchar"><a href="#putchar" class="headerlink" title="putchar"></a>putchar</h3><p><code>int puchar(int c) ; </code><br>向标准输出写一个字符<br>返回写了几个字符，EOF(-1)表示写失败 </p><h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h3><p><code>int getchar(void) ; </code><br>从标准输入读入一个字符<br>返回类型是int是为了可以返回EOF(-1)  </p><blockquote><p>Window Ctrl-Z  Unix Ctrl-D</p></blockquote><h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><p>在string.h中，有许多帮助处理字符串的函数</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p><strong>strlen</strong><br>size_t strlen(const char *s) ;<br>返回s的字符串长度，不包括结尾的0    </p><p><strong>strcpy</strong><br>char * strcpy(char *restrict dst , const char *restrict src) ;<br>可以把<code>src</code>的字符串拷贝到<code>dst</code><br>在c99下，restrict表名src和dst不重叠<br>最终返回的是<code>dst</code><br>另外，参数中，注意第一个参数是目的地，第二个是源<br>目的地需要有足够空间    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *dst = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)+<span class="number">1</span>) ;</span><br><span class="line"><span class="comment">// +1是因为考虑末尾的0</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst,src) ; </span><br></pre></td></tr></table></figure><p>自主实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">myCpy</span><span class="params">(<span class="type">char</span>* dst , <span class="type">const</span> <span class="type">char</span>* src)</span>&#123;</span><br><span class="line">    <span class="type">char</span>* ret = dst ; </span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        *dst = *src ; </span><br><span class="line">        dst++ ; </span><br><span class="line">        src++ ; </span><br><span class="line">    <span class="comment">//或者 *dst++ = *src++ ; </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *dst = <span class="string">&#x27;\0&#x27;</span>  ;</span><br><span class="line">    <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>strcat</strong><br>char * strcat(char *restric s1 , const char *restrict s2) ;<br>把s2拷贝到s1的后面，接触成一个长的字符串<br>返回s1<br>s1需要有足够的空间  </p><blockquote><p>尽可能不要使用strcpy和strcat因为有安全问题，可以使用下面的安全版本    </p></blockquote><p>char * strncpy(char *restrict dst , const char *restrict src , sizr_t n) ;<br>chat * strcat(char *restrict s1 , const char *restrict s2 , size_t n) ;<br>int strncmp(const char *s1 , const char *s2 , size_t n );</p><p>size_t n 参数表示了最多可以运输多少字符 </p><p>int strncmp :判断前n个字符是否是xxx </p><h3 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a>字符串搜索函数</h3><p>char * strchr(const char *s , int c);<br>char * strrchr(const char *s , int c);<br>返回NULL表示没有找到<br>(前者是从左往右，后者是从右往左)    </p><p>因为返回的是对应位置的指针，所以也可以尝试打印接下来的部分：    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span> ; </span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">strchr</span>(s,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span> , p );</span><br></pre></td></tr></table></figure><p>最后结果会是”llo”<br>因此我们可以利用这个特性寻找第n个字符，比如：   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span> ; </span><br><span class="line"><span class="type">char</span> *p =s <span class="built_in">strchr</span>(s,<span class="string">&#x27;l&#x27;</span>) ;</span><br><span class="line">p = strchur(p+<span class="number">1</span>,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span> , p );</span><br></pre></td></tr></table></figure><h3 id="在字符串中寻找字符串"><a href="#在字符串中寻找字符串" class="headerlink" title="在字符串中寻找字符串"></a>在字符串中寻找字符串</h3><p>char * strstr(const char *s1 , const char *s2);<br>char * strcasestr(const char *s1 , const char *s2); &#x2F;&#x2F;相较前者，忽略大小写  </p>]]></content>
    
    
    <summary type="html">该部分主要是对于前两篇之后,对于字符串部分的补充说明</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【基础C语言】四、指针与字符串(下)</title>
    <link href="http://example.com/2022/03/08/%E5%9B%9B%E3%80%81%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2(%E4%B8%8B)/"/>
    <id>http://example.com/2022/03/08/%E5%9B%9B%E3%80%81%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2(%E4%B8%8B)/</id>
    <published>2022-03-08T02:00:00.000Z</published>
    <updated>2022-03-08T16:48:15.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四、指针与字符串"><a href="#四、指针与字符串" class="headerlink" title="四、指针与字符串"></a>四、指针与字符串</h1><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>&amp;可以取出一个地址，而取出的地址的大小是由当前的架构环境所确定的</p><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>在64位架构之下，int为4个字节，而其所对应的地址是8个字节<br>在32位架构下，二者都是4个字节   </p><h3 id="amp-取地址"><a href="#amp-取地址" class="headerlink" title="&amp;取地址"></a>&amp;取地址</h3><p>首先它不可以对没有地址的东西取地址，比如<code>&amp;(i+P)</code> （i+p是变量）<br>换言之，必须在&amp;的右侧，*<strong>存在一个明确的变量</strong>，才可以去取得它的地址</p><p>对于数组而言，比如有数组a[]<br>当我们取出地址时，<code>&amp;a,a,a[0]</code>是相同的<br>而相邻数组之间的差距一直为4</p><h2 id="变量地址"><a href="#变量地址" class="headerlink" title="变量地址"></a>变量地址</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针地址的变量，就是保存地址的变量  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i ; </span><br><span class="line"><span class="type">int</span>* p = &amp;i ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两行的意思是一样的</span></span><br><span class="line"><span class="comment">//都是p是一个地址，而q是普通的int</span></span><br><span class="line"><span class="type">int</span>* p,q;</span><br><span class="line"><span class="type">int</span> *p,q;</span><br></pre></td></tr></table></figure><h4 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h4><p>变量的值是内存的地址<br>普通变量的值是实际的值<br>指针变量的值是具体实际值的变量的地址    </p><h3 id="作为参数的指针"><a href="#作为参数的指针" class="headerlink" title="作为参数的指针"></a>作为参数的指针</h3><p>void f(int *p);<br>在被调用的时候需要了某个变量的地址  </p><p>int i &#x3D; 0 ;<br>f(&amp;i);<br>在函数里面可以通过这个指针访问外面这个i </p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符*"></a>运算符*</h3><p>*是一个单目运算符，用来访问指针的值所表示的地址上的变量<br>可以做右值(读)也可以做左值(写)  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = *p ; </span><br><span class="line">*p = k+<span class="number">1</span> ;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上，我们可以使用&amp;来取得所需要的变量的地址，而使用*来访问某个指针所指向的变量<br>A.<br>*&amp;a -&gt; *(&amp;a) -&gt; *(a的地址) -&gt;得到地址上的变量 -&gt; a</p><p>B.<br>&amp;*a -&gt; &amp;(*a)-&gt; &amp;(指针所指向的变量) -&gt; 得到a的地址</p><h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2><h3 id="使用指针交换两个变量的值"><a href="#使用指针交换两个变量的值" class="headerlink" title="使用指针交换两个变量的值"></a>使用指针交换两个变量的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *pa , <span class="type">int</span> *pb)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t = *pa ;</span><br><span class="line">    *pa = *pb ;</span><br><span class="line">    *pb = t ;</span><br><span class="line">    <span class="comment">//因为传入的是指针,因此在函数内部的修改可以影响出去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><p>有的时候函数返回一个值是不够的，想要函数返回多个值，某些值就只能通过指针返回<br>传入的参数实际上就包含<strong>需要保存并带回结果的变量</strong><br>再次以刚才的swap函数，我们传入的两个参数需要互换值，也就说最后需要两个返回值，于是我们就需要两个指针    </p><blockquote><p>虽然这些参数是主函数传进去的参数，但是它们作用的结果是把结果“带”出来  </p></blockquote><h4 id="函数返回运算的状态，而结果通过指针返回"><a href="#函数返回运算的状态，而结果通过指针返回" class="headerlink" title="函数返回运算的状态，而结果通过指针返回"></a>函数返回运算的状态，而结果通过指针返回</h4><p>实际上和前文的意思是相同的<br>比如常用的情况就是让函数返回不属于有效范围内的值表示出错(比如下标是-1)<br>但如果返回任何值都是有效值，就无法通过返回值来表示其结果了，于是就需要分开返回<br>一般的做法是“运算状态”用函数返回，而实际的值通过指针参数来返回  </p><blockquote><p>在java或者c++中，可以通过”异常”这个机制来解决这个问题 </p></blockquote><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>在任何一个地址变量被赋值&#x2F;得到一个地址 之前，不能通过它(使用*)访问任何变量   </p><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><h3 id="传入的数组"><a href="#传入的数组" class="headerlink" title="传入的数组"></a>传入的数组</h3><p>实际上，在调用函数的时候，我们所传入的数组就是<strong>一个指针</strong>，这也是为什么在函数里面使用<code>sizeof</code>时得到的是4(32位架构)<br>因为此时所谓的“数组”,其实就是一个指针   </p><blockquote><p>事实上，如果我们把原本函数中形参的数组都改成指针，比如int a[] 改为 *a  , 并不会影响编译   </p></blockquote><p>总言之，函数参数表中的数组实际上就是指针，<code>sizeof(a) == sizeof(int*)</code>,而它可以用数组的运算符[]进行运算<br>所以，下面四种函数原型是等价的  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar,<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> * ,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[] , <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[] , <span class="type">int</span>)</span>;s</span><br></pre></td></tr></table></figure><p><strong>数组变量是特殊的指针</strong>    </p><h3 id="数组与数组单元"><a href="#数组与数组单元" class="headerlink" title="数组与数组单元"></a>数组与数组单元</h3><p>数组变量本身就可以表达地址，所以使用<code>int a[10] ; int*p = a ;</code>的时候，无需使用&amp;来获取其地址<br>但是数组内的单元,表达的都是<strong>变量</strong>，<strong>需要使用&amp;来获取地址</strong><br>另外，a &#x3D;&#x3D; &amp;a[0]    </p><p>[]运算符是可以对数组做，亦可以对指针做<br>p[0]:当做这里有一个数组，它所指向的第一个位置就是所需的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;min ; <span class="comment">//这里我们假设之前得到了一个最小值min</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d \n&quot;</span> , *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[0] = %d \n&quot;</span> , p[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//此时二者得到的结果是一样的</span></span><br></pre></td></tr></table></figure><p>同理，*运算符可以对指针做，亦可以对数组做   </p><p>数组变量是const的指针，也就是说它不能被赋值</p><h2 id="指针和所对应的值的const情况-C99"><a href="#指针和所对应的值的const情况-C99" class="headerlink" title="指针和所对应的值的const情况(C99)"></a>指针和所对应的值的const情况(C99)</h2><h3 id="指针是const"><a href="#指针是const" class="headerlink" title="指针是const"></a>指针是const</h3><p>指针是const,换言之，就是<strong>指针是固定的</strong><br>也就是说，该指针，<strong>指向了某个位置</strong>，这个事实是不能改变的  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;i ; <span class="comment">//q指向了i</span></span><br><span class="line">*q = <span class="number">26</span> ; <span class="comment">//可行，意思是q指针指的地方的值修改为26</span></span><br><span class="line">q++; <span class="comment">//ERROR,q指针自身的值不可变</span></span><br></pre></td></tr></table></figure><h3 id="所指的位置是const"><a href="#所指的位置是const" class="headerlink" title="所指的位置是const"></a>所指的位置是const</h3><p>表示的是，不能再通过<strong>这个指针去修改那个变量</strong><br>值得注意的是，该操作不代表“那个变量”成为了const </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i ; </span><br><span class="line">*p = <span class="number">26</span> ; <span class="comment">//ERROR,在这里(*p)是一个const</span></span><br><span class="line">i = <span class="number">26</span> ; <span class="comment">//是可以的，因为i本身并不是const</span></span><br><span class="line">p = &amp;j ; <span class="comment">//p指针也不是const,因此可以随意更改指向</span></span><br></pre></td></tr></table></figure><p>简而言之，就是p指针，和它所指向的变量都是可以改变的<br>但是“通过p指针来修改该变量(*p)”这一方法是不可行的   </p><h4 id="判断方式"><a href="#判断方式" class="headerlink" title="判断方式"></a>判断方式</h4><p>const在前面：它所指的东西不能被修改 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;i ; </span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* p2 = &amp;i ; </span><br></pre></td></tr></table></figure><p>const在后面: 表示指针不能被修改 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> p3 = &amp;i ;</span><br></pre></td></tr></table></figure><h4 id="const-指针被用于函数"><a href="#const-指针被用于函数" class="headerlink" title="const+指针被用于函数"></a>const+指针被用于函数</h4><p>比如void f(const int* x) ;<br>其表示“在这个函数的范围内，保证int* x 是不会被修改的”   </p><h2 id="const与数组"><a href="#const与数组" class="headerlink" title="const与数组"></a>const与数组</h2><p>比如const int a[] &#x3D; {1,2,3,4,5,6} ;<br>实际上所谓“数组变量”就已经是const的指针了<br>而这里我们加入了const,代表数组内的每个单元都是const int<br>所以必须且只能通过初始化来赋值  </p><blockquote><p>所以说在把数组传到函数里面的时候，如果你不希望函数修改你的数组，则使用const</p></blockquote><h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><h3 id="普通加减"><a href="#普通加减" class="headerlink" title="普通加减"></a>普通加减</h3><p>对于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ac[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,&#125; ;</span><br><span class="line"><span class="type">char</span> *p = ac ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p = %p \n&quot;</span>,p); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p = %p \n&quot;</span> , p+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>得到的结果(示例)是<br>p   &#x3D; 0xbffbbd5e<br>p+1 &#x3D; 0xbffbbd5f    </p><p>但是如果是  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ai[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,&#125; ;</span><br><span class="line"><span class="type">int</span> *q = ai[<span class="number">0</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;q = %p \n&quot;</span>,q); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;q+1 = %p \n&quot;</span> , q+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>得到的结果却\是<br>p   &#x3D; 0xbffbbd2c<br>p+1 &#x3D; 0xbffbbd30<br>差值是4 </p><p><strong>原因</strong>是sizeof(char) &#x3D; 1 ; sizeof(int) &#x3D; 4<br>所以<br><strong>指针上的+1指的是增加一个sizeof()的单位</strong><br>比如此时 *p代表的是ac[0],那么*(p+1)代表的就是ac[1] </p><blockquote><p>则指针和数组的转换方式为  *(p+n) –&gt; ac[n]</p></blockquote><blockquote><p>实质上，如果你的指针原先并不是指向了一片连续的空间，那么这种运算是没有意义的  </p></blockquote><p>同理，也可以给指针使用+,+&#x3D;,-,-&#x3D;,++,–等等   </p><h3 id="指针之间的运算"><a href="#指针之间的运算" class="headerlink" title="指针之间的运算"></a>指针之间的运算</h3><p>两个指针是可以相减的(相加大概率没有实际意义)<br>结果并不是地址的差，而是(地址差)&#x2F;sizeof()<br>也就是说,指针相减,表示的是<strong>二者中间有多少”这种类型的东西”</strong>    </p><h3 id="p"><a href="#p" class="headerlink" title="*p++"></a>*p++</h3><p>意义是“取出p所指的那个数据，然后再利用指针++,把p移到下一个位置去”   </p><blockquote><p>*的优先级没有++高 </p></blockquote><p>这个操作常用于数组类的连续空间操作，而在某些cpu上，这可以直接被翻译成一条汇编指令   </p><p>比如我们就可以把遍历数组的代码写为  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ac[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">-1</span>&#125; ; <span class="comment">//最后一个-1表示这是数组的结尾   </span></span><br><span class="line">    <span class="type">char</span> *p = &amp;ac[<span class="number">0</span>] ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span> , *p++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针的比较"><a href="#指针的比较" class="headerlink" title="指针的比较"></a>指针的比较</h3><p>进行比较的操作，&lt;,&lt;&#x3D; , &#x3D;&#x3D; , &gt; , &gt;&#x3D; , !&#x3D; 都可以被用于指针的比较<br>当我们进行指针的比较的时候,比较的是<strong>指针在内存中的地址</strong><br>此外，数组中的单元的地址肯定是线性递增的    </p><h3 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a>0地址</h3><p>理所当然的，我们的内存中是存在0地址的，但是这个位置通常是一个不能随便用的地址   </p><blockquote><p>因此我们的指针不可以具有0值   </p></blockquote><p>由此，我们可以利用这个特性，用0地址来表示一些特殊的事情，比如：<br>1.返回的指针是无效的<br>2.指针并没有被真正初始化(先初始化为0)   </p><p>在很多时候，NULL就是一个预定义好的符号，它表示0地址(在C语言的编译器里就是NULL，需要全部大写) </p><blockquote><p>此外，有的编译器不愿意你用0来表示0地址，因此想这么用的时候，尽量用NULL    </p></blockquote><h3 id="指针类型与大小"><a href="#指针类型与大小" class="headerlink" title="指针类型与大小"></a>指针类型与大小</h3><p>无论指向的是什么类型，所有的<strong>指针的大小</strong>都是一样的，因为它们本质上都是地址<br>但是指针存在类型的差别，<strong>不同类型的指针是不能相互赋值的</strong><br>(这是避免用错指针)  </p><p>不过，如果真的需要的话，是可以进行指针类型转换的    </p><h4 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h4><p>void*表示不知道指向什么东西的指针，在计算时与char* 相同(但二者并不相通)<br>指针是具有转换类型的，比如<code>int *p = &amp;i ; void*q = (void*)p ;</code><br>这种操作并不会改变p所指向的变量的类型，而是让后面的程序以”不同的眼光”看p所指的变量<br>比如这个时候，后续的程序就不认为p指向的是int,而是认为它指向了p<br>(尽量不要使用)  </p><p>void* : 表示这是一个指针，但不确定它指向的是什么    </p><h3 id="小结：我们可以用指针来做什么"><a href="#小结：我们可以用指针来做什么" class="headerlink" title="小结：我们可以用指针来做什么"></a>小结：我们可以用指针来做什么</h3><p>需要传入一个较大的数据的时候的参数<br>传入数组后对数组进行操作<br>函数返回不止一个结果<br>需要用函数来修改不止一个变量<br>动态申请内存    </p><h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><h3 id="在C99之前的事"><a href="#在C99之前的事" class="headerlink" title="在C99之前的事"></a>在C99之前的事</h3><p>在C99之前，我们不可以使用变量作为数组定义的大小，因此需要手动为它分配好内存<br><code>int* a = (int*)malloc(n*sizeof(int)) ;</code><br>下面我们就尝试一下这件事情  </p><blockquote><p>在使用malloc之前，我们需要引入一个全新的头文件stdlib.h&gt;   </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> number ; </span><br><span class="line">    <span class="type">int</span>* a ; </span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数量：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;number) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在C99，我们可以之间 int a[number] ; 来得到数组    </span></span><br><span class="line">    </span><br><span class="line">    a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(number * <span class="keyword">sizeof</span>(<span class="type">int</span>)) ; <span class="comment">//注意，我们此时要的并不是“有多少个单元”，而是“这些单元将会占据多少空间” </span></span><br><span class="line">    <span class="comment">//因为malloc的结果是void*,我们还需要改变它为int*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后利用指针和整数的等同性，我们这时候就直接把a当作数组使用即可</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;number ; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i = number<span class="number">-1</span> , i&gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束后需要把空间归还</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>来自<code>#include &lt;stdlib.h&gt;</code><br>void* malloc(size_t size) ;<br>向malloc申请的空间的大小是以<strong>字节</strong>为单位的<br>返回的结果是void*,<strong>需要类型转换为自己需要的类型</strong><br><code>(int*)malloc(n*sizeof(int))</code>  </p><p>申请失败时会返回一个0，或者NULL </p><h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>free是和malloc配套的函数，把申请来的空间重新归还给系统<br>只能还申请来的空间的<strong>首地址</strong>，也就是地址改变之后(比如p++,p–)是不可以归还的<br>必须归还最开始的，申请来的那个地址  </p><p>为了配合，<strong>建议在初始化指针的时候都给它一个0地址，如 void *p &#x3D; 0;</strong><br>如此一来，若我们在运行过程中没有malloc这个指针，最终归还的时候也是free(p)也是就free(NULL)，不会报错    </p><blockquote><p>free(NULL)总是可以的      </p></blockquote><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>1.申请了不free<br>在小程序里面当然没有影响，但是越大越重要的程序，在长时间运行中，内存就会逐渐下降    </p><p>2.free再free<br>要是之前已经free过了，系统会把这个地址从申请名单中删去，若是再free，就会崩溃    </p><p>3.free变过的地址<br>前文已经说过</p>]]></content>
    
    
    <summary type="html">这部分是指针和字符串的结合,是初期C语言学习的重点部分,因此分了三个部分来记录</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【基础C语言】三、指针与字符串(上)</title>
    <link href="http://example.com/2022/03/08/%E4%B8%89%E3%80%81%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2(%E4%B8%8A)/"/>
    <id>http://example.com/2022/03/08/%E4%B8%89%E3%80%81%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2(%E4%B8%8A)/</id>
    <published>2022-03-08T00:00:00.000Z</published>
    <updated>2022-03-08T16:48:15.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、指针与字符串"><a href="#三、指针与字符串" class="headerlink" title="三、指针与字符串"></a>三、指针与字符串</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>我们从sizeof谈起：它是一个<code>运算符``。给出某个类型或变量在内存中占据的位置，以字节大小表示（1字节=4比特） 接着是&amp;，它实质上是一个</code>运算符&#96;&#96;，它能够<strong>获得变量的地址</strong>（这也意味着它的操作对象必须是变量）,&amp;不能对没有地址的东西取地址，比如a++,++a,a+b等等</p><blockquote><p>简单来说，利用<code>sizeof</code>，我们可以得到一个类型&#x2F;变量内存占据位置的大小<br>使用<code>&amp;</code>，我们可以得到该变量在内存中的地址</p></blockquote><p>顺带一提，用printf输出<code>地址</code>时，使用%p , 而且取出的地址大小是否和int相同取决于编译器（32位架构还是64位架构）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span> , &amp; i) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><h3 id="指针是什么"><a href="#指针是什么" class="headerlink" title="指针是什么"></a>指针是什么</h3><p>我们一直所说的“指针”，是真正的能够<strong>存储地址</strong>的变量</p><blockquote><p>指针,指的就是保存地址的变量<br>我们使用<code>星号*</code> 表示某个变量，是一个指针 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int *p,q ; 这里面的p是指针，而q就是普通的整型  </span><br><span class="line"></span><br><span class="line">#### 指针变量</span><br><span class="line">普通变量的值是实际的值</span><br><span class="line">指针变量的值是**具有实际值的变量**的**地址**   </span><br><span class="line"></span><br><span class="line">\*是一个单目运算符，用来**访问**指针的值所表示的地址上的变量</span><br><span class="line">它可以做右值，也可以做左值</span><br><span class="line">```c</span><br><span class="line">int k = *p ; </span><br><span class="line">*p = k+1 ;</span><br></pre></td></tr></table></figure><p>由于指针变量的特殊性，我们若在函数中修改了指针变量，<strong>那么也会修改它所指向的值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> k)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">6</span> ; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i);</span><br><span class="line">    f(&amp;i);</span><br><span class="line">    g(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span> <span class="params">(<span class="type">int</span> *p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span> , p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span> , *p);</span><br><span class="line">    *p = <span class="number">26</span> ; <span class="comment">//就在这里，把p变量的地址指向的那个变量（就是i）改为26</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span> <span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k = %d \n &quot;</span> , k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="小结-指针-地址-和-amp"><a href="#小结-指针-地址-和-amp" class="headerlink" title="小结: 指针,地址,*和&amp;"></a>小结: 指针,地址,*和&amp;</h3><p>到这里也许有一些混乱,为了接下来内容的进行先进行一次小结:<br>1.什么是地址?<br>地址指的是”变量地址”,意思是在内存中,某个变量的值,被放置在了这里</p><p>2.怎么获得地址?<br>利用<code>&amp;</code>操作符可以获得地址,引用一句话:</p><blockquote><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址</p></blockquote><p>3.怎么记住地址&#x2F;怎么操作这块地址&#x2F;什么是指针?<br>利用<code>*</code>对某个变量进行操作,表示<strong>该变量存储着一个地址</strong>,这种变量就被叫为指针</p><blockquote><p>其实意会一下就简单了,”指针”,意思就是这个变量的意义,就是”指向”某块地址</p></blockquote><p>利用<code>*</code>在一个变量之前,就是代表这个变量是个指针(用来存地址的)<br>那么怎么对这个指针操作呢,一般而言,可以使用<code>&amp;</code>符号来获得某个变量的地址,然后将其赋给指针(写)<br>而使用<code>*</code>,则是得到所指定地址的变量的值(读)</p><blockquote><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值.</p></blockquote><p>4.实例<br>来自菜鸟教程的两个简单易懂的实例<br><a href="https://www.runoob.com/cprogramming/c-pointers.html">C指针</a></p><p>第一个实例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="type">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var 变量的地址: %p\n&quot;</span>, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ip 变量存储的地址: %p\n&quot;</span>, ip );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码编译会得到结果:<br>var 变量的地址: 0x7ffeeef168d8<br>ip 变量存储的地址: 0x7ffeeef168d8<br>*ip 变量的值: 20</p><p>第二个实例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var_runoob = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p;              <span class="comment">// 定义指针变量</span></span><br><span class="line">    p = &amp;var_runoob;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var_runoob 变量的地址： %p\n&quot;</span>, p);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果:<br>var_runoob 变量的地址： 0x7ffeeaae08d8<br>这里用图说明即是<br><img src="https://s2.loli.net/2022/03/08/RyhLfQ4XjDZxYvu.png"></p><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>函数的参数表中的数组，实质上就是个指针(这也是为什么写a[]和a[10]之类的是一样的)，<br>因此在函数中我们<strong>不能直接用sizeof</strong>得到正确的数组长度</p><blockquote><p>函数参数表中的数组实际上是指针，但是可以用数组的运算符[]来运算  </p></blockquote><p>数组变量是特殊的指针,这使得它有如下性质<br>1.数组变量本身表达地址，所以我们取数组的地址时无需使用&amp;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] ; </span><br><span class="line"><span class="type">int</span> *p = a ; </span><br><span class="line">```   </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span>但是数组的单元表达的是变量，我们需要用&amp;来取它。数组a的地址，等于数组单元a[<span class="number">0</span>]的地址</span><br><span class="line">&gt; 可以想象为数组是一系列连续的指针地址构成的,其中第一位(下标为<span class="number">0</span>的)那一位代表整个数组的开始</span><br><span class="line"><span class="number">3.</span>*运算符可以对指针做，也可以对数组做</span><br><span class="line"><span class="number">4.</span>数组变量是<span class="type">const</span>的指针，所以不能被**赋值**</span><br><span class="line"></span><br><span class="line">## 字符类型</span><br><span class="line"></span><br><span class="line">### CHAR  </span><br><span class="line"><span class="type">char</span>是最小的整数类型，同时也是一特殊的类型：字符</span><br><span class="line">原因在于：</span><br><span class="line"><span class="number">1.</span>用单引号表示的字符字面量 <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="number">2.&#x27;&#x27;</span>也是字符</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span> <span class="built_in">scanf</span> 里用```%c```来输入输出字符</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">char</span> c ; </span><br><span class="line"><span class="type">char</span> d ; </span><br><span class="line">c = <span class="number">1</span> ; </span><br><span class="line">d = <span class="string">&#x27;1&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %d \n&quot;</span> , c) ; <span class="comment">// 结果是1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d = %d \n&quot;</span> , d) ; <span class="comment">// 结果是49,对应1在ASCII的值  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的两个1，一个是整型，而另外一个是字符(因此d打印出来是49)</p><blockquote><p>%c 表示以字符的形式输入&#x2F;输出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span> ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c \n&quot;</span> , c) ; </span><br><span class="line">c++ ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c \n&quot;</span> , c) ; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="string">&#x27;Z&#x27;</span> - <span class="string">&#x27;A&#x27;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span> ,i ) ;s</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">&gt; a+<span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span> 可以把一个大写字母变成小写字母</span><br><span class="line">&gt; a+<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span> 可以把一个小写字母变成大写字母</span><br><span class="line">  </span><br><span class="line">### 逃逸字符  </span><br><span class="line">逃逸字符用来表示无法印出来的控制字符或特殊字符，它由一个反斜杆<span class="string">&quot;\\&quot;</span> 开头 ， 后面跟上对应的字符  </span><br><span class="line"></span><br><span class="line">\\b  回退一格  </span><br><span class="line">\\t  到下一表格位  (也就是制表位上的位置，是每行固定的位置（试着敲一下tab）,利用\\t 可以使上下行对齐)</span><br><span class="line">\\n  换行  </span><br><span class="line">\\r  回车  </span><br><span class="line">\\<span class="string">&quot;  双引号  </span></span><br><span class="line"><span class="string">\\&#x27;  单引号  </span></span><br><span class="line"><span class="string">\\\   反斜杠本身</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 字符串  </span></span><br><span class="line"><span class="string">在C语言中，字符串指以0（整数0）结尾的一串字符   </span></span><br><span class="line"><span class="string">0和&#x27;\\0&#x27;是一样的，但是和&#x27;0&#x27;是不一样的  </span></span><br><span class="line"><span class="string">0标志着字符串的结束，但是它不是字符串的一部分，计算字符串长度的时候也不包含这个0</span></span><br><span class="line"><span class="string">字符串以数组的形式存在，也以数组或指针的形式访问（更多的是以指针的形式）  </span></span><br><span class="line"><span class="string">在string.h中有很多处理字符串的函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 字符串变量</span></span><br><span class="line"><span class="string">我们有多种方式表达字符串</span></span><br><span class="line"><span class="string">```c</span></span><br><span class="line"><span class="string">char *str = &quot;</span>Hello<span class="string">&quot; ;</span></span><br><span class="line"><span class="string">char word[] = &quot;</span>Hello<span class="string">&quot; ;</span></span><br><span class="line"><span class="string">char line[10] = &quot;</span>Hello<span class="string">&quot; ;</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这里面 &quot;</span>Hello<span class="string">&quot;被称为**字符串常量**,&quot;</span>Hello<span class="string">&quot;会被编译器变成一个字符数组放在某处，这个数组长度是6，结尾还有表示结束的0(Hello五位,0一位,共六位)  </span></span><br><span class="line"><span class="string">两个相邻的字符常量会自动连接</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 小结</span></span><br><span class="line"><span class="string">C语言的字符串是以字符数组的形态存在的，不能用运算符对字符串做运算，通过数组的方式可以遍历字符串  </span></span><br><span class="line"><span class="string">唯一特殊的地方是字符串字面量可以用来初始化字符数组  </span></span><br><span class="line"><span class="string">以及标准库提供了一系列字符串函数  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 字符串常量（续）  </span></span><br><span class="line"><span class="string">```c</span></span><br><span class="line"><span class="string">char* s = &quot;</span>Hello , world!<span class="string">&quot;; //我要指向某个地方的字符串</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string">s是一个指针，初始化为指向一个字符串常量  </span></span><br><span class="line"><span class="string">由于这个常量所在的地方，实质上是s是const char* s , 不过由于历史原因，编译器接受不带const的写法  </span></span><br><span class="line"><span class="string">但是当我们试图对s所指的字符串做写入的时候会导致严重后果  </span></span><br><span class="line"><span class="string">当我们编译过程中有两个相同的字符串（比如s1 s2 两个字符串都是Hello world），它们会指向同一个地方  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">如果想要制作一个能修改的字符串，那么在**一开始**就需要用**数组**定义  </span></span><br><span class="line"><span class="string">```c</span></span><br><span class="line"><span class="string">char s[] = &quot;</span>Hello, world!<span class="string">&quot; ; //某个地方的字符串就在这里  </span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">##### 区别</span></span><br><span class="line"><span class="string">```c</span></span><br><span class="line"><span class="string">int i =0 ; </span></span><br><span class="line"><span class="string">char *s = &quot;</span>Hello , World<span class="string">&quot;;</span></span><br><span class="line"><span class="string">char *s2 = &quot;</span>Hello,World<span class="string">&quot; ;</span></span><br><span class="line"><span class="string">char s3[] = &quot;</span>Hello,World<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">printf(&quot;</span>&amp;i=%p\n<span class="string">&quot;, &amp;i) ;</span></span><br><span class="line"><span class="string">printf(&quot;</span>&amp;s =%p\n<span class="string">&quot;, &amp;s) ;</span></span><br><span class="line"><span class="string">printf(&quot;</span>&amp;s2=%p\n<span class="string">&quot;, &amp;s2) ;</span></span><br><span class="line"><span class="string">printf(&quot;</span>&amp;s3=%p\n<span class="string">&quot;, &amp;s3) ;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">s3[0] = &#x27;B&#x27; ; </span></span><br><span class="line"><span class="string">printf(&quot;</span>Here!s3[<span class="number">0</span>] = %c\n<span class="string">&quot;,s3[0]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return 0 ;</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string">该部分输出会类似:</span></span><br><span class="line"><span class="string">&amp;i=0x7ffe7f63052c</span></span><br><span class="line"><span class="string">&amp;s =0x7ffe7f630520</span></span><br><span class="line"><span class="string">&amp;s2=0x7ffe7f630518</span></span><br><span class="line"><span class="string">&amp;s3=0x7ffe7f63050c</span></span><br><span class="line"><span class="string">Here!s3[0] = B</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数组字符串：这个字符串在这，作为本地变量会被自动回收  </span></span><br><span class="line"><span class="string">指针字符串：不知道这个字符串在哪，需要处理参数，可以动态分配空间  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果要构造一个字符串--&gt;数组  </span></span><br><span class="line"><span class="string">如果要处理一个字符串--&gt;指针  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">&gt;字符串可以表达为char\*的形式,char\*不一定是字符串,只有在它所指的字符数组有结尾0，我们才能说它所指的是字符串  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 字符串计算  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">### 赋值</span></span><br><span class="line"><span class="string">```c</span></span><br><span class="line"><span class="string">char *t = &quot;</span>title<span class="string">&quot; ;</span></span><br><span class="line"><span class="string">char *s ;</span></span><br><span class="line"><span class="string">s = t ;</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string">实际上并没有产生新的字符串，只是让指针s指向了t所指的字符串。对s的任何操作就是对t做的,**因为二者指向同一块地址**  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">### 输入输出</span></span><br><span class="line"><span class="string">%s代表输入输出的是字符串   </span></span><br><span class="line"><span class="string">```c</span></span><br><span class="line"><span class="string">char string[8];</span></span><br><span class="line"><span class="string">scanf(&quot;</span>%s<span class="string">&quot;,string);</span></span><br><span class="line"><span class="string">printf(&quot;</span>%s<span class="string">&quot;,string);</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string">&gt;scanf读入一个单词，到空格、tab、回车为止  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">想要在空格tab回车之后继续读，我们需要再来一个scanf，而且第二个scanf是不会读到&quot;</span>空格tab回车<span class="string">&quot;的  </span></span><br><span class="line"><span class="string">但是scanf实质上是不安全的，因为不知道要读入的内容的长度  </span></span><br><span class="line"><span class="string">在百分号和s中间，可以增加一个数字，表示我们希望最多可以读入多少字符，以此提高安全性。此时就不一定是以空格tab回车来区分了，读完了，这个scanf就结束了  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 常见错误 </span></span><br><span class="line"><span class="string">```c</span></span><br><span class="line"><span class="string">char *string ; </span></span><br><span class="line"><span class="string">scanf(&quot;</span>%s<span class="string">&quot;,string);</span></span><br></pre></td></tr></table></figure><p>因为char*是字符串类型，定义了一个字符串变量string就可以直接使用了，但实际上这种做法是十分危险的,因为你不知道使用者会读入多少内容  </p><pre><code class="c">char buffer[100] = &quot;&quot;; //空字符串，buffer[0] == &#39;\0&#39; char buffer[] = &quot;&quot; ;//数这个数组的长度只有1！</code></pre><h3 id="字符串-附录"><a href="#字符串-附录" class="headerlink" title="字符串_附录"></a>字符串_附录</h3><p>字符串相关的更多补充请见《五、字符串补充》</p>]]></content>
    
    
    <summary type="html">这部分是指针和字符串的结合,是初期C语言学习的重点部分,因此分了三个部分来记录</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【基础C语言】一、基础操作</title>
    <link href="http://example.com/2022/03/07/%E4%B8%80%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/03/07/%E4%B8%80%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2022-03-07T08:00:00.000Z</published>
    <updated>2022-03-08T16:48:15.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础操作"><a href="#一、基础操作" class="headerlink" title="一、基础操作"></a>一、基础操作</h1><p>本文包括C语言的基础操作，如果您已经学过其他语言，建议跳过或者迅速浏览即可   </p><h2 id="起手式Hello-World"><a href="#起手式Hello-World" class="headerlink" title="起手式Hello World"></a>起手式Hello World</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello \nWorld!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  \n是换行符号，注意是\n  不是/n </span></span><br><span class="line"></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有语言开始的仪式<br>在C里面，利用printf打印&#x2F;输出我们想要的东西 </p><h2 id="基础运算和输入输出"><a href="#基础运算和输入输出" class="headerlink" title="基础运算和输入输出"></a>基础运算和输入输出</h2><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>加减乘除和小学数学没什么两样。这里主要讲讲新东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```%```:取余，这家伙得到的就是余数了，比如5%2=1  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;7/5=%d&quot;,7/5) //%d代表输入“”，后面的运算。符号+-*/是加减乘除 %是取余 （）是括号 </span><br><span class="line">    //%取余表示取两个数相除之后的余数，且只会显示余数</span><br><span class="line"></span><br><span class="line">; return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```A+= 5``` 实质上是和 ```A= A+5```是相同的，注意前者的+=之间是不能有空格的  </span><br><span class="line">同理，```A*= B+12``` 实质等同于 ```A= A*(B+12)```  </span><br><span class="line"></span><br><span class="line">常用的是++和--，```a++```就是```a+=1```也就是```a=a+1``，减法同理  </span><br><span class="line">a++和++a有细微的差别    </span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int a;</span><br><span class="line">   a = 10;</span><br><span class="line">   </span><br><span class="line">   printf(&quot; 这个是a++的式子 %d \n&quot;, a++);</span><br><span class="line">   printf(&quot;而结果是 a= %d  \n&quot;,a);</span><br><span class="line">   </span><br><span class="line">   printf(&quot; 这个是++a的式子 %d \n&quot;, ++a); </span><br><span class="line">   printf(&quot;而结果是 a= %d  \n&quot;,a); </span><br><span class="line"></span><br><span class="line">   ;return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="用scanf进行输入"><a href="#用scanf进行输入" class="headerlink" title="用scanf进行输入"></a>用scanf进行输入</h3><p><code>scanf(&quot;%d&quot;,&amp;price);</code>   </p><p>我们使用 scanf 把一些东西输入，这里表示把<code>&quot;&quot;</code>中的结果赋值给price变量，注意变量前的&amp;要打</p><blockquote><p>至于&amp;是什么呢，这个要到指针部分我们再细说<br>可以同时定义多个输入量，每一个%d和之后所写的变量的<strong>一一对应</strong>  </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> price=<span class="number">0</span>; <span class="comment">//定义了一个变量，名字是price，类型int，初始值是0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入金额&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price);</span><br><span class="line"></span><br><span class="line"><span class="comment">// scanf(&quot;%d %d&quot;,&amp;a,&amp;b); 可以同时定义多个输入量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> change=<span class="number">100</span>-price;</span><br><span class="line"><span class="comment">//定义了第二个变量，并且还做了计算 </span></span><br><span class="line"><span class="comment">//100是常量，为了方便修改的话我们也可以给常量整一个名字 const int AMOUNT= 100即可 </span></span><br><span class="line"><span class="comment">//const为修饰符，加在int前面时代表给变量一个不变的属性，在初始化后，该变量的值便不能修改 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找您%d 元&quot;</span>,change)</span><br><span class="line"></span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"> &#125; </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">### 变量、赋值、初始化</span><br><span class="line">变量定义的一般形式是 ```&lt;变量类型&gt;&lt;变量名称&gt;;```  如```<span class="type">int</span> price;```    </span><br><span class="line">每一个变量都有一个唯一的标识符，只能由字母、数字、下划线组成，且数字不能在第一个位置。</span><br><span class="line">&gt; 标识符，通俗的说就是变量的名字。关键字不能作为标识符，比如你不能<span class="type">int</span> <span class="type">int</span> = <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">所有变量必须有确定的数据类型，表示变量中可以存放什么类型的数据，运行过程中不能改变类型</span><br><span class="line">&gt;C99可以在变量使用前定义它都可以，而传统的ANSI C只能在代码开头定义变量</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> price=<span class="number">0</span>; <span class="comment">//定义了一个变量，名字是price，类型int，初始值是0</span></span><br><span class="line"><span class="comment">//int A,B 可以同时定义两个为A,B的变量，类型同为int </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言的关键字不能做标识符 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入金额&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> change=<span class="number">100</span>-price;</span><br><span class="line"><span class="comment">//定义了第二个变量，并且还做了计算 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找您%d 元&quot;</span>,change)</span><br><span class="line"></span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>我们使用整型int进行运算时，结果只会是<strong>整数</strong><br>想要得到小数部分，我们需要浮点数  </p><p>这里先介绍两种浮点数已经符号：<br>float:单精度浮点数，使用float时，用%f<br>double:双精度浮点数，使用double时，用%lf     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第一行整数的测试%d     &quot;</span>,<span class="number">10</span>/<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第二行浮点数的测试%f&quot;</span>,<span class="number">10.0</span>/<span class="number">3</span>); </span><br><span class="line"><span class="comment">//此时的%f与10.0一起表示出了浮点数。让计算可以延续至小数 </span></span><br><span class="line"><span class="comment">//当浮点数和整数放到一起运算的时候，C会把整数转化成浮点数，然后进行浮点数的运算 </span></span><br><span class="line"></span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//double“双”是“双精度浮点数”的第一个单词，另外float（浮点）表示单精度浮点数 </span></span><br><span class="line"> <span class="comment">//使用double时，用%lf </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>double可表示的范围比float更大，吃的内存也比它多<br>各个变量范围的区别和用法之后再提   </p><h3 id="小结：一个使用输入框和结果的例子"><a href="#小结：一个使用输入框和结果的例子" class="headerlink" title="小结：一个使用输入框和结果的例子"></a>小结：一个使用输入框和结果的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 运算符是指进行运算的的动作，比如加法运算符是 +，另外=也是运算符 </span></span><br><span class="line"><span class="comment">//算子是指参与运算的值，可能是常数、变量、一个方法的返回值 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hour1,minute1;</span><br><span class="line"><span class="type">int</span> hour2,minute2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入“第一个小时的时分”如一点三十为 1 30  &quot;</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d %d&quot;</span>,&amp;hour1,&amp;minute1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入“第二个小时的时分”如三点三十为 3 30  &quot;</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d %d&quot;</span>,&amp;hour2,&amp;minute2);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> time1=hour1*<span class="number">60</span>+minute1;</span><br><span class="line"><span class="type">int</span> time2=hour2*<span class="number">60</span>+minute2;</span><br><span class="line"><span class="type">int</span> t=time2-time1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;时间差是%d小时%d分钟。&quot;</span>,t/<span class="number">60</span>,t%<span class="number">60</span>);</span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"> &#125; </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 判断语句与循环语句</span><br><span class="line">了解了判断语句和循环语句，再加上输入输出，差不多已经完成最最基础的入门了    </span><br><span class="line"></span><br><span class="line">### 判断语句</span><br><span class="line">#### 基础</span><br><span class="line">我们利用<span class="keyword">if</span>语句进行判断      </span><br><span class="line"><span class="keyword">if</span>语句的标准写法：  </span><br><span class="line">```C</span><br><span class="line"><span class="title function_">if</span><span class="params">(条件成立)</span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    &#125;    </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">判断条件：</span><br><span class="line">判断的条件的符号如下:    </span><br><span class="line">== 相等   </span><br><span class="line">    ！=不相等 </span><br><span class="line">&gt; 大于    </span><br><span class="line">    &gt;= 大于或等于 </span><br><span class="line">&lt;小于     </span><br><span class="line">    &lt;= 小于或等于   </span><br><span class="line"></span><br><span class="line">注意，在C里面，判断的结果并不是布尔值(<span class="literal">true</span>,<span class="literal">false</span>)，而是<span class="number">1</span>和<span class="number">0</span>  </span><br><span class="line"></span><br><span class="line">我们使用```<span class="keyword">else</span>语句```，表示除了<span class="keyword">if</span>条件之外的情况下所做的操作  </span><br><span class="line"></span><br><span class="line">**代码实例**:  </span><br><span class="line">```C</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> bill =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入金额 &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入票面 &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;bill); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bill&gt;=price)     <span class="comment">//注意了，if和else的分号;不写在小括号后面，因为这不是他们真正“结束”的地方 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;应该找您： %d \n&quot;</span>, bill-price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当判断运算符输出不为0时，会执行大括号内的语句，否则执行else语句。</span></span><br><span class="line"><span class="comment">if+else判断完之后，之后的语句照常进行 */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你的钱不够  \n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;执行结束&quot;</span>); </span><br><span class="line"></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>和<span class="keyword">else</span>有另外一种不用大括号的写法，但是为了可读性一般不建议使用  </span><br><span class="line">```C</span><br><span class="line"><span class="keyword">if</span>(hours&gt;STANDARD)</span><br><span class="line">  pay=STANDARD*RATE+(hours-STANDARD)*(RATE*<span class="number">1.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pay=hours*RATE;</span><br></pre></td></tr></table></figure><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>不管是if语句还是if-else语句，我们都可以进行嵌套<br>什么是嵌套呢，见到来说就是一个判断语句中再次使用判断语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c) ;</span><br><span class="line"><span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当if的条件满足或不满足时，执行的语句可以是一条if或者一套if-else语句，这就是嵌套的if语句 </span></span><br><span class="line"><span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;c)&#123;</span><br><span class="line">max=a;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">max=c;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&gt;c)&#123;</span><br><span class="line">max=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">max=c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !!! 简洁版的else总是和最近的if相匹配！而完整版的（有大括号）是根据大括号的划分的范围匹配的！</span></span><br><span class="line"><span class="comment">//在C中缩进格式并不能暗示else的匹配</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The max is %d \n&quot;</span>,max);</span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h4><p>if 后的else语句可以直接再接if语句，就是<code>else if语句</code>  </p><figure class="highlight plaintext"><figcaption><span>if()```表示，在第一句条件不成立的情况下，再次进行判断</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">```C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123; </span><br><span class="line">int x ;</span><br><span class="line">int f = 0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    if(x&lt;0) &#123;</span><br><span class="line">    f = -1;</span><br><span class="line">&#125;else if (x==0)&#123;</span><br><span class="line">f = 0;</span><br><span class="line">&#125;else if (x&gt;5)&#123;</span><br><span class="line">f=2*x;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">f=3*x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d&quot;,f)</span><br><span class="line">;return 0 ;</span><br><span class="line"> &#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### switch case 多路分支</span><br><span class="line">可以使用swtich case 来减少一些if else的工作量  </span><br><span class="line">这里的工作量指的是你复制粘贴的工作量  </span><br><span class="line">在很多时候，```switch case```开销略大，且有很多要注意的细节，因此反而比```if-else```少用</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">switch( type )&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type表示的是当前判断的变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;常量&gt; ： 常量可以是常数，也可以是只含常数运算的表达式） </span><br><span class="line">语句...（一般以<span class="keyword">break</span>结尾）</span><br><span class="line"><span class="keyword">break</span>; </span><br></pre></td></tr></table></figure><p>利用case来对各种情况进行分析</p><p>一个switch-case的使用实例如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> type;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;type);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span>( type )&#123;</span><br><span class="line"><span class="comment">//根据switch(控制表达式子)，控制表达式只能是整数型的结果！ </span></span><br><span class="line"><span class="comment">//括号中的值判定接下来的语句，括号中可以是变量，可以是式子。都不符合就输出default。 </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是case 1&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ; </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是case 2&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ; </span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是case 3&quot;</span>);</span><br><span class="line"><span class="comment">//break ; 注意这个break被注释删掉了，case=3时会执行3然后到执行case4后停止！ </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是case 4&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;阿这，这不是case1234&quot;</span>);</span><br><span class="line"><span class="comment">//最后以default结尾来对应其他情况。 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>case只是一个路标，并不会自动停止。甚至会运行到下一条case里面去执行句子（按排序的顺序）<br>这个动作会直到遇到一个break或者到达switch结束，才会停止下来。</p></blockquote><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>最最基本的循环，生动形象地表现了“当…时，一直…”的思想  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;</span><br><span class="line">    执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行语句中要有改变条件的语句，不然就是死循环  </p><h4 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h4><p>和上面那位没什么区别，主要在于：<br>while是先判断条件，在决定要不要执行语句<br>do-while是<strong>无论怎样先执行一次</strong>，执行完再判断  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   循环体语句 </span><br><span class="line">&#125;<span class="keyword">while</span> (循环条件);</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环和while循环是等价互通的  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始条件;继续循环的条件;参数更新)&#123;</span><br><span class="line">    执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>和判断语句一样，循环是可以嵌套使用的  </p><h4 id="小结与实例"><a href="#小结与实例" class="headerlink" title="小结与实例"></a>小结与实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,count);<span class="comment">// a</span></span><br><span class="line">count--;               <span class="comment">//b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发射！\n&quot;</span>); </span><br><span class="line"><span class="comment">//当我们想要模拟测试一个比较大的循环时，可以采用一个小的数进行实验。 </span></span><br><span class="line"><span class="comment">//比如我们想要知道ab顺序带来的不同时，可以先用count = 3 进行测试。 </span></span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h4 id="循环中的break与continue"><a href="#循环中的break与continue" class="headerlink" title="循环中的break与continue"></a>循环中的break与continue</h4><p>这是两个可以表示结束循环的句子<br><strong>break</strong>:表示结束循环，直接结束循环跳出循环<br><strong>continue</strong>：结束本次循环，不执行接下来的语句直接进行下一次循环  </p><p>实例：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> x ; </span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>,&amp;x) ; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i ;</span><br><span class="line"><span class="type">int</span> k =<span class="number">0</span> ;<span class="comment">//设置一个数值k来勇于判断最后的文字输出 </span></span><br><span class="line"><span class="keyword">if</span>(x ==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1就是1&quot;</span>);<span class="comment">//1的情况 </span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (x&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EOORO&quot;</span>); <span class="comment">//错误的情况 </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;x;i++)&#123; <span class="comment">//从2开始到x-1 </span></span><br><span class="line"><span class="keyword">if</span>(x%i == <span class="number">0</span>) &#123;</span><br><span class="line">k =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//!!在循环里面，运行至break时，结束该次循环（在这里加入是为了防止重复运算） </span></span><br><span class="line"><span class="comment">//continue :跳过循环这一轮剩下的语句进入下一轮（不做接下来的语句，回到循环开头） </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (k==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;不是素数&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;是素数&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C语言最基础的操作,包含Hello World , 输出输入 , 判断与循环语句的操作</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【基础C语言】二、C语言的数组、函数、基础搜索算法</title>
    <link href="http://example.com/2022/03/07/%E4%BA%8C%E3%80%81C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%95%B0%E7%BB%84%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%9F%BA%E7%A1%80%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/03/07/%E4%BA%8C%E3%80%81C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%95%B0%E7%BB%84%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%9F%BA%E7%A1%80%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-07T08:00:00.000Z</published>
    <updated>2022-03-08T16:48:15.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言的数组、函数、基础搜索算法"><a href="#C语言的数组、函数、基础搜索算法" class="headerlink" title="C语言的数组、函数、基础搜索算法"></a>C语言的数组、函数、基础搜索算法</h1><p>稍微进阶一点，对于学过其他语言的朋友，只需要看看在C里面，它们是怎么写的即可</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种把元素集合在一个地方的方式</p><h3 id="数组初步介绍"><a href="#数组初步介绍" class="headerlink" title="数组初步介绍"></a>数组初步介绍</h3><p>当我们要存储同一类型的多个变量时，我们使用<strong>数组</strong><br>可以把数组看成一个篮子，相同类型的变量全部放进去  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;数组类型&gt; &lt;名字&gt; [大小] ;</span><br><span class="line">如： <span class="type">int</span> GroupA [<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">通俗来说，就是:</span><br><span class="line">&lt;类型&gt; &lt;名称&gt; [元素数量]        这里的类型是指数组内部存储的数据的类型 </span><br><span class="line"><span class="type">int</span> grades[<span class="number">100</span>]; </span><br><span class="line"><span class="type">char</span> weight[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>数组通过<strong>下标 index</strong>来访问对应位置的变量，下标从0开始<br>我们上面定义了大小为100的数组，则下标范围是0-99  </p><p>元素数量必须是整数</p><blockquote><p>在C99之前：元素数量必须是编译时刻确定的字面量 (不能是变量、程序运行过程中动态产生的数字)</p></blockquote><p><strong>数组定义实例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//写一个程序，计算平均数并输出大于平均数的数字 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x ;</span><br><span class="line"><span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="type">int</span> number [<span class="number">100</span>]; <span class="comment">//定义一个数组，其大小为100个 </span></span><br><span class="line"><span class="comment">//int 名字A [大小X] 表示这个数组A里面最多可以放 X个int    </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span> (x! = <span class="number">-1</span>)&#123;</span><br><span class="line">number [cnt] = x ;  <span class="comment">//让数组上cnt位置的那个单元=x ；而cnt是递增的，所以x分别会在1，2，3....位置上存放 </span></span><br><span class="line"><span class="comment">//对数组中的元素进行赋值</span></span><br><span class="line"> </span><br><span class="line">sum += x ;</span><br><span class="line">cnt ++;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (cnt &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f \n&quot;</span>,sum/cnt);</span><br><span class="line"><span class="type">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i&lt;cnt;i++)&#123;  <span class="comment">//进行数组数字的输出。遍历数组</span></span><br><span class="line"><span class="comment">//遍历数组:浏览整个数组 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (number[i]&gt;sum/cnt)&#123;<span class="comment">//使用数组中的元素 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,number[i]);</span><br><span class="line"><span class="comment">//当数组i位置的数符合条件，输出它 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>1.数组中的元素具有相同的数据类型<br>2.一旦创建，数组不能改变其大小<br>3.使用数组时在[]中的数字是下标&#x2F;索引，下标从0开始计数<br>4.！！无论是编译器还是运行环境，都不会去检查下标是否越界，无论你在读还是写(segmentation fault)<br>5.数组中的元素在内存中是连续依次排列的<br>6.可以创建长度为0的数组，但是没什么锤子用   </p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>我们把数放到一个方形区域里来，通过”行+列”来确定一个元素，就像一个坐标&#x2F;一个表格<br>二维数组的定义和使用同一维，不过它有两个中括号，代表行列，<strong>先行后列</strong>   </p><p>遍历二维数组将利用嵌套循环<br>下面是二维数组的定义和使用的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> a [<span class="number">3</span>][<span class="number">5</span>] ; <span class="comment">//定义了一个三行五列的矩阵，定义基本都是先行(y数)后列(x数)的</span></span><br><span class="line"><span class="type">int</span> therow = <span class="number">3</span> ; </span><br><span class="line"><span class="type">int</span> thecol = <span class="number">5</span> ;</span><br><span class="line"><span class="comment">//二维数组的遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; therow ;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;thecol;j++)&#123;</span><br><span class="line">a [i][j] = (i+<span class="number">1</span>)*(j+<span class="number">1</span>) ;  <span class="comment">//数组名字+数组下标，就可以表示这是一个普通的变量了，可以在一些地方直接使用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组初始化</span></span><br><span class="line"><span class="type">int</span> b [][<span class="number">5</span>] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">列数是不可以省略的，函数可以让编译器自己整</span></span><br><span class="line"><span class="comment">每个&#123;&#125;之间使用大括号隔开，最后一个的逗号存不存在无所谓，如果省略，表示“补零”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的集成初始化"><a href="#数组的集成初始化" class="headerlink" title="数组的集成初始化"></a>数组的集成初始化</h3><p>集成初始化时的定位：<br>1.用[n]在初始化数据中给出定位<br>2.没有定位的数据会接在前面的位置后面<br>3.其它位置的数值同前文，补为0<br>4.也可以不给出数组的大小，让编译器自己算<br>5.这种做法比较适合初始数据稀疏的数组   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a [] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;  <span class="comment">//集成初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;  <span class="comment">//这里提一句，很多时候习惯使用&lt;某个阙值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \t&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一开始就规定了数组的大小，但是没有填充完数组，那么会把剩余未规定的部分全部初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int a [10] =&#123;2&#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//int b[10] = &#123;[0] = 2 , [2] =3 ,6 ,&#125;;  只能在C99下使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof可以给出整个数组所占据的内容的大小，单位为字节。在整形数组中，一个单位4字节</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n %d \n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n %d \n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n 所以a的大小就是 %d \n&quot;</span>,<span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof(a) / sizeof(a[0] 起到了Java中类似与length系列的作用</span></span><br><span class="line"></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组不能直接被赋值，像 int b [] &#x3D; a 是不行的,我们只能使用遍历来完成这件事<br>数组作为函数参数时，我们习惯于用另一个参数来传入数组的大小</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数，又叫方法。可以看作函数是一系列代码的代表</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>&lt;返回值&gt; &lt;函数名字&gt;(参数表){<br>    函数执行，如果有返回值的话要return<br>}</p><p>比如我们定义一个加法的函数sum  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="type">int</span> i ; </span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>(i=begin ; i&lt;=end ;i++)&#123;</span><br><span class="line">sum+= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d 到 %d的和是%d \n&quot;</span>,begin,end,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的意思就是，输入一个<code>begin</code>和<code>end</code>，得到程序会打印出它们的和</p><p>定义的函数要写在用它的地方之前才行，比如我想在主函数中使用sum函数，就要先写它<br>实例：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="type">int</span> i ; </span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>(i=begin ; i&lt;=end ;i++)&#123;</span><br><span class="line">sum+= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d 到 %d的和是%d \n&quot;</span>,begin,end,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在这里，我们在主函数之前定义了一个自己的函数sum </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>);<span class="comment">//在这里，我们运用了自己的sum函数 </span></span><br><span class="line">sum(<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">sum(<span class="number">35</span>,<span class="number">45</span>); </span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>显然，这样子并不美观，那么我们可以先用原型声明来“占位”  </p><h3 id="原型声明"><a href="#原型声明" class="headerlink" title="原型声明"></a>原型声明</h3><p>我们可以现在最开始声明我们这个函数的基本内容，而不写执行代码<br>然后在主函数结束后，再在后面<strong>补上</strong>对应的执行代码<br>比如：   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//C的编译器是由上而下来分析代码的，这导致你要用的函数需要在前面先写出来</span></span><br><span class="line"><span class="comment">//但是可以把函数头加上分号放在前面，其它部分放在后面，这样就可以了。这个做法叫做  原型声明 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span> <span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>;  <span class="comment">//声明 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;  <span class="comment">//定义 </span></span><br><span class="line"><span class="type">int</span> i ; </span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (i =a ; i &lt;=b ; i ++)&#123;</span><br><span class="line">sum +=<span class="number">1</span> ;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外，原型声明里面可以只给参数类型，不给参数名字。因为原型声明的意义就是让编译器知道有这个东西 </span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">### 返回值<span class="keyword">return</span></span><br><span class="line">返回返回值的操作是必不可少的，而且要和你所声明的返回值的数据类型对应    </span><br><span class="line">当然，如果你声明返回值是<span class="type">void</span>（无）,那就不用<span class="keyword">return</span>了   </span><br><span class="line">```C</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> 、</span></span><br><span class="line"><span class="comment">//当使用void类型的函数时，函数是没有返回值的，也就是可以没有return </span></span><br><span class="line"><span class="type">int</span> max (<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;<span class="comment">//返回值是int类型的函数max </span></span><br><span class="line"><span class="type">int</span> ret ; </span><br><span class="line"><span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">ret = a ; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">ret = b ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ; <span class="comment">//返回一个ret的数值，另外在一个函数里面可以有多个return语句，而且return不一定要在尾（不过这不是单一出口，习惯不好） </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/* return </span></span><br><span class="line"><span class="comment">1.return 会停止函数的运行，并且返回一个值</span></span><br><span class="line"><span class="comment">2.写法  return &lt;值&gt; ;  或者  return[表达式] ;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a,b,c ; </span><br><span class="line">c = max(<span class="number">12</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n &quot;</span>,c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">### 参数传递和本地变量</span><br><span class="line">函数每次运行都产生独立的变量空间   </span><br><span class="line">在这个空间中的变量是它这次运行独有的，称为**本地变量**   </span><br><span class="line">定义在函数内部的变量就是**本地变量/局部变量**    </span><br><span class="line">参数也是**本地变量/局部变量**   </span><br><span class="line"></span><br><span class="line">**生存期**：变量从出现到消失的时间     </span><br><span class="line">**作用域**：该变量可以起作用的范围    </span><br><span class="line">对于本地变量，二者属于一个范围，那就是大括号内，我们把他叫**块**  </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>本地变量是定义在块内的，可以是函数块内，也可以是语句块内   </span><br><span class="line"><span class="number">2.</span>程序运行到某个块之前，该块其中的变量是不存在的，离开了之后，其中的变量也会消失</span><br><span class="line">块外面定义的变量在块里面是依然生效的</span><br><span class="line"><span class="number">3.</span>如果块里面定义了和外面同名的变量，那么块内的变量会覆盖外面的</span><br><span class="line"><span class="number">4.</span>一个块中是不能定义同名变量的</span><br><span class="line"><span class="number">5.</span>本地变量不会被默认初始化，参数在进入函数的时候被初始化了</span><br><span class="line"></span><br><span class="line">在使用函数/方法的时候，目前为止我们传入的只是“值”而非这个变量</span><br><span class="line">&gt; 后面学到的内容会有传入的是地址/指针...</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//以下内容请利用debug辅助理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样的代码可以完成a、b数值的互换吗   答案是不可以 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span> ; </span><br><span class="line"><span class="type">int</span> b = <span class="number">16</span> ; </span><br><span class="line"></span><br><span class="line">swap(a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d b = %d&quot;</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="comment">//虽然在这里的参数是a b ，刚才传进来的数值也是a b ，但实质上二者是完全不同的东西</span></span><br><span class="line"><span class="comment">//swap函数中，只是把a的值5，以及把b的值16 给到了swap的形式参数a b 里面，此ab非彼ab</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> t = a ;</span><br><span class="line">a = b ; </span><br><span class="line">b = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>1.void f(void) 表示f函数没有参数<br>void f()      表示f函数的参数表未知（传统C）   </p><p>2.逗号在圆括号内算作标点符号，而不是运算符<br>f(a,b) 传入a,b<br>f((a,b))  传入(a,b)，此时我们要的是(a,b)而非a,b。因此逗号会被当作运算符被使用  </p><p>3.C语言不允许在函数里面定义函数   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">()</span>; <span class="comment">//原型声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span> ; </span><br><span class="line"><span class="type">int</span> b = <span class="number">6</span> ; </span><br><span class="line"></span><br><span class="line"><span class="comment">//原型声明的时候外面没有指定参数，在这里外面尝试传入两个int</span></span><br><span class="line">swap(a,b); <span class="comment">//而事实上，我们的函数会对两个double进行处理，因此结果会出错（但是运行是正常的）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d \n&quot;</span>,a,b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里给的是double</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span> <span class="params">(<span class="type">double</span> a , <span class="type">double</span> b)</span>&#123;</span><br><span class="line"><span class="type">int</span> t = a ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;IN SWAP,a = %f , b = %f  \n&quot;</span>,a,b);</span><br><span class="line">a = b ; </span><br><span class="line"></span><br><span class="line">b = t ; </span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 基础的搜索算法</span><br><span class="line">这里稍微介绍一下搜索算法</span><br><span class="line"></span><br><span class="line">### 线性搜索</span><br><span class="line">最简单、最基础、最粗暴的搜索：遍历所有数据，检索目标</span><br><span class="line">```C</span><br><span class="line">    <span class="type">int</span> <span class="title function_">searcher</span><span class="params">(<span class="type">int</span> key , <span class="type">int</span> a[] , <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//这里附带说明一下，由于C语言的函数的关系，我们最好还是把数组长度直接传进来</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span> ; i &lt;len ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == a[i])&#123;</span><br><span class="line">            ret = i ; </span><br><span class="line">            <span class="keyword">break</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会查找数组中的某个数，找到了就会输出它的位置，否则输出-1</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>不断对半分的搜索方法<br>用的地方是一个<strong>已经排序好的数组</strong> , 它的效率显然高于普通遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> key ,  <span class="type">int</span> a[] , <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span> ;</span><br><span class="line">    <span class="type">int</span> right = len <span class="number">-1</span> ;</span><br><span class="line">    <span class="comment">//定义好边缘的那两个点</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left+right)/<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == k)&#123;</span><br><span class="line">            ret = mid ; </span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">            <span class="comment">//如果找到了就设置ret为这个值并且返回</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[mid]&gt;k)&#123;</span><br><span class="line">            right = mid <span class="number">-1</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid +<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C语言中数组的基础表示和使用,C语言中函数的使用和规定,以及遍历搜索与二分搜索</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Unity】利用代码查找Active为False的物体</title>
    <link href="http://example.com/2022/02/27/%E5%9C%A8Unity%E4%B8%AD%E6%9F%A5%E6%89%BEActive%E4%B8%BAfalse%E7%9A%84%E7%89%A9%E4%BD%93/"/>
    <id>http://example.com/2022/02/27/%E5%9C%A8Unity%E4%B8%AD%E6%9F%A5%E6%89%BEActive%E4%B8%BAfalse%E7%9A%84%E7%89%A9%E4%BD%93/</id>
    <published>2022-02-26T16:00:00.000Z</published>
    <updated>2022-03-08T16:50:16.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用Unity进行开发，我们经常需要让一些代码和对应的物体&#x2F;组件关联，而大多数开发者会选择直接在编辑器界面通过拖拽来完成这个操作<br>这个方法简单又简便，但就本人的一点经验而言，有以下弊端<br>1.有些时候重复拖拽非常麻烦<br>2.没办法在运行中解决绑定的需求，这一点在切换场景的时候特别容易造成错误  </p><blockquote><p>因此，拖拽是有极限的，所以我选择代码</p></blockquote><p>利用代码绑定的方法很多(见文章末尾附录)，其中有一个小问题就是<strong>如何查找Active为False的物体</strong><br>如果我们使用一般的方法(直接GameObject.FindXXX系列指令)，是无法获得Active为False的物体的<br>本文就旨在解决<strong>利用代码查找Active为False的物体</strong>这个问题   </p><h1 id="Transform-Find"><a href="#Transform-Find" class="headerlink" title="Transform.Find"></a>Transform.Find</h1><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>答案就是使用<code>Transform.Find()</code>方法，transfor可以通过曾经关系来查找到<strong>active为false的节点</strong><br>唯一需要注意的是，Transform.Find()进行的是<strong>逐层查找</strong>，也就是说只能找到子物体，而<strong>不能找到孙物体</strong><br>当我们想要找到孙物体的时候，只能一级一级往下拨</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>如果，比如此时我们想获得”UI”下的”TextBackGround”物体(可以看到此时它Active &#x3D;&#x3D; false)<br><img src="https://s3.bmp.ovh/imgs/2022/02/0d35d70c0febd910.png">   </p><p>于是我们需要写下(前后文略)：    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject theDialog ; </span><br><span class="line"><span class="keyword">public</span> GameObject UI ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    UI = GameObject.Find(<span class="string">&quot;UI&quot;</span>);</span><br><span class="line">    theDialog = UI.transform.Find(<span class="string">&quot;TextBackGround&quot;</span>).gameObject ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们完成了”找到UI物体”-&gt;”在“UI”下寻找其子物体”的操作    </p><p>这里我是由于”UI”这个物体还有用，因此这么写，你也可以尝试直接<strong>一步到位</strong>    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theDialog = (GameObject.Find(<span class="string">&quot;UI&quot;</span>)).transform.Find(<span class="string">&quot;TextBackGround&quot;</span>).gameObject ;</span><br></pre></td></tr></table></figure><h1 id="如果根节点-x2F-父节点也是false怎么办"><a href="#如果根节点-x2F-父节点也是false怎么办" class="headerlink" title="如果根节点&#x2F;父节点也是false怎么办"></a>如果根节点&#x2F;父节点也是false怎么办</h1><p>建议直接建个空的gameObject放它们…然后把它设置为Active &#x3D; true<br>然后“空gameObjetc” -&gt; “根物体” -&gt; “子物体”  </p><p>如果不想这么干，就需要使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnityEngine.SceneManagement.SceneManager.GetActiveScene().GetRootGameObjects();</span><br><span class="line">Resources.FindObjectsOfTypeAll(<span class="keyword">typeof</span>(GameObject)) ; </span><br></pre></td></tr></table></figure><p>就不在这里赘述了，如何使用可以详见官方手册，很详细</p>]]></content>
    
    
    <summary type="html">在Unity编辑器中，如果利用拖拽的方法来获得设置为false的物体是很简单的，但是用代码的话会麻烦一点点</summary>
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C#基础学习(三)</title>
    <link href="http://example.com/2022/02/08/C#%E5%AD%A6%E4%B9%A0_%E4%B8%89/"/>
    <id>http://example.com/2022/02/08/C#%E5%AD%A6%E4%B9%A0_%E4%B8%89/</id>
    <published>2022-02-07T16:00:00.000Z</published>
    <updated>2022-08-12T07:55:31.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>泛型类就是一个<strong>模子</strong>，装入对应类型的材料，就可以塑造出想要的产品</p><h4 id="语法展示"><a href="#语法展示" class="headerlink" title="语法展示"></a>语法展示</h4><p>比如我们想要设计一个笼子类，填充对应的宠物类型来得到专属的笼子</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cage</span>&lt;<span class="title">T</span>&gt;&#123;</span><br><span class="line">    T[] petsArray ; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PutIn</span>(<span class="params">T pet</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">TakeOut</span>(<span class="params"><span class="built_in">int</span> index</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T就是一个<strong>占位符</strong>，等具体参数传入之后，它就会变成对应的东西</p><h4 id="Why泛型"><a href="#Why泛型" class="headerlink" title="Why泛型"></a>Why泛型</h4><p>用基类或者公告的接口，甚至是所有类的基类Object，也可以实现上述的Cage类————但是类型过于<strong>宽泛</strong><br>1.需要显示转换类型<br>2.需要判定真实的类型是什么</p><h4 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cage</span>&lt;<span class="title">T</span>&gt;&#123;...&#125; <span class="comment">//声明</span></span><br><span class="line">Cage&lt;Dog&gt; dogCahe ;  <span class="comment">//Cage&lt;Dog&gt;类型的引用</span></span><br><span class="line">dogCage = <span class="keyword">new</span> Cage&lt;Dog&gt;(); <span class="comment">//构造实例</span></span><br></pre></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>1.代码量更小，无论多少种类型，都只需要一个实现<br>2.只有需要的类型才会被实例化<br>3.易于维护，修改一次模板，所有的实例都会被改变  </p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>泛型方法就是<strong>方法的模型</strong>，给定具体的类型，就可以实例化出一个操作该类型的具体方法  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DogisHappy</span>&lt;<span class="title">T</span>&gt;(<span class="params">T target</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>约束就是<strong>控制泛型</strong>的条件，用于缩小<strong>泛型参数</strong>的范围<br>只有添加了约束，才能调用泛型参数中的方法，否则只能调用object的方法  </p><blockquote><p>泛型类和方法都可以添加约束，比如可以约束为“只有是IClimbTree，才能调用爬树方法”    </p></blockquote><p>约束类型：<br>1.类名：该类或者继承该类的类<br>2.class:可以用任何类<br>3.struct:可以是任何值<br>4.接口名：该接口类型或者任何实现该接口的类型<br>5.new()：带有无参共有构造函数的类   </p><h3 id="约束叠加规则"><a href="#约束叠加规则" class="headerlink" title="约束叠加规则"></a>约束叠加规则</h3><p>A.主约束：只能有一个，可以是<strong>类名,class,struct</strong><br>B.接口约束:可以有任意多个<br>C.构造约束</p><h3 id="约束语法"><a href="#约束语法" class="headerlink" title="约束语法"></a>约束语法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Cage&lt;T&gt;    <span class="keyword">where</span> T:Pet,IClimbTress,<span class="keyword">new</span>()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>where T 表示<strong>想要约束哪个类型参数</strong>，在该例子中，T：<br>1.只能是Pet或者其派生类<br>2.需要会爬树，即实现了IClimbTree接口<br>3.有默认构造函数</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>泛型接口允许我们将接口成员的<strong>参数</strong>和<strong>返回类型</strong>设置为泛型参数的接口  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyself</span>&lt;<span class="title">T</span>&gt;&#123;</span><br><span class="line">    <span class="function">T <span class="title">Myself</span>(<span class="params">T self</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span>:<span class="title">IMyself</span>&lt;<span class="title">A</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">Myself</span>(<span class="params">A self</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们定义一个学习技能的接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ILearn</span>&lt;<span class="title">A</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Act</span>(<span class="params">A cmd</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Labrador</span>:<span class="title">Dog</span>,<span class="title">ILearn</span>&lt;<span class="title">Sit</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Act</span>(<span class="params">Sit cmd</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是一种存放多个数据的容器类型，比如Array是最简单的一种集合‘</p><h3 id="预定义的常用集合"><a href="#预定义的常用集合" class="headerlink" title="预定义的常用集合"></a>预定义的常用集合</h3><p>动态数组ArrayList<br>列表List<br>字典Dictionary<br>队列Queue<br>栈Stack</p><h3 id="动态数组ArrayList"><a href="#动态数组ArrayList" class="headerlink" title="动态数组ArrayList"></a>动态数组ArrayList</h3><p>1.初始化的时候可以不指定大小<br>2.使用Count属性来获取长度<br>3.使用Add进行添加<br>4.删除Remove和RemoveAt(根据对象删除和根据索引删除)<br>5.使用[index]访问</p><h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List<T></h3><p>ArrayList是不安全的，而且需要在装箱拆箱中消耗性能<br>可以利用List<T>泛型的优越性</p><h3 id="字典Dictionary-lt-TKey-Tvalue-gt"><a href="#字典Dictionary-lt-TKey-Tvalue-gt" class="headerlink" title="字典Dictionary&lt;TKey,Tvalue&gt;"></a>字典Dictionary&lt;TKey,Tvalue&gt;</h3><p>字典是用来<strong>存储一系列键值对</strong>的容器，每个值对应一个唯一的键<br>键的意义在于，我们可以通过键相对高效地访问到值  </p><p>1.得到数量使用Count属性<br>2.添加Add(key,value)<br>3.删除Remove(利用键或值删除均可)<br>4.使用dic[“Key”]进行访问</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span>&#123;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>,Dog&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,Dog&gt;();</span><br><span class="line"></span><br><span class="line">    dic.Add(<span class="string">&quot;A&quot;</span>,<span class="keyword">new</span> Dog(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    dic.Add(<span class="string">&quot;B&quot;</span>,<span class="keyword">new</span> Dog(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">    dic.Add(<span class="string">&quot;C&quot;</span>,<span class="keyword">new</span> Dog(<span class="string">&quot;C&quot;</span>));</span><br><span class="line"></span><br><span class="line">    dic[<span class="string">&quot;A&quot;</span>].PrintName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h3><p>后进先出的容器</p><p>Pop:出栈<br>Push:入栈<br>Peek：获取栈顶部的元素</p><h3 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h3><p>先进先出的容器<br>Dequeue:出队<br>Enqueue:入队<br>(入队需要一个参数，而出队会得到一个返回值)</p>]]></content>
    
    
    <summary type="html">对于C#的学习，一般用于Unity使用者的补强比较好</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>C#基础学习(二)</title>
    <link href="http://example.com/2022/02/07/C#%E5%AD%A6%E4%B9%A0_%E4%BA%8C/"/>
    <id>http://example.com/2022/02/07/C#%E5%AD%A6%E4%B9%A0_%E4%BA%8C/</id>
    <published>2022-02-06T16:00:00.000Z</published>
    <updated>2022-08-12T07:48:00.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h1><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>被标识为<code>static</code>的字段、方法。属性、构造函数、事件，就是静态成员</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> Num ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员将会被类的所有实例共享，所有实例都访问同一内存位置</p><blockquote><p>就是说，“静态”的成员，对于该类的实例，就是“公共”的</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>静态成员<strong>直接通过类名</strong>访问，它们仅仅和整个类有关<br><code>Dog.Num += 1 ; </code></p><p><strong>生存周期</strong><br>独立于任何实例，没有实例也可以访问。<br>其初始化语句在任何静态成员使用之前调用</p><h4 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h4><p>静态函数不能访问实例成员，仅能访问<strong>其他静态成员</strong><br>（不过实例成员反过来可以访问静态函数）</p><h4 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h4><p>1.静态构造函数用于<strong>初始化静态字段</strong>(为静态成员而生)<br>2.在引用任何静态成员之前，和创建任何实例之前调用<br>3.与类同名，使用static，无参数，无访问修饰符</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Dog</span>()</span>&#123;</span><br><span class="line">        num = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>1.如果类只包含了静态的方法和属性，并且标识为了static ,那么它就是一个<strong>静态类</strong><br>2.静态类不能创建实例，不能被继承<br>3.可以为静态类定义一个静态构造函数</p><blockquote><p>静态类主要用于基础类库(数字库)和扩展方法</p></blockquote><h4 id="如何扩展方法"><a href="#如何扩展方法" class="headerlink" title="如何扩展方法"></a>如何扩展方法</h4><p>1.如果有源代码，直接添加一个新方法<br>2.如果不能修改但也不是密闭类，可以派生子类扩展<br>3.如果以上条件都不能满足，可以使用静态类扩展方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PetGuide</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">HowToFeed</span>(<span class="params"><span class="keyword">this</span> Dog dog</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过传入原来的类到一个静态类中，达到静态类扩展方法的目的<br><strong>加上this关键字后，就代表这是一个扩展方法。在Dog类的实例中，可以直接被调用</strong>   </p><p><strong>就像是Dog()自己原本就有的方法一样</strong></p><p>1.扩展方法所属的类，必须是static类<br>2.扩展方法本身必须是static方法<br>3.扩展方法的第一个参数类型，必须是 <strong>this + 类名</strong></p><h1 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h1><h2 id="转换和操作符重载"><a href="#转换和操作符重载" class="headerlink" title="转换和操作符重载"></a>转换和操作符重载</h2><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p>装箱:根据值类型的值，在堆上创建一个完整的引用类型对象，并返回对象的引用。这是一种<strong>隐式转换</strong>   </p><blockquote><p>在有的时候需要将值类型转化为引用类型来进行统一的操作和统一的存储，因此我们需要装箱<br>一般而言，引用类型就是object，而统一的操作是通过“作为函数的参数传入”完成的，统一存储则是统一存储为 object[]</p></blockquote><p>装箱示例:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">3</span> ;</span><br><span class="line"><span class="built_in">object</span> oi = <span class="literal">null</span> ;</span><br><span class="line">oi = i ;</span><br></pre></td></tr></table></figure><blockquote><p>装箱的本质就是<strong>在堆上创建了引用类型的副本</strong>，新创建的引用类和原来的值类型<strong>相互独立</strong>    </p></blockquote><p>拆箱：装箱的逆操作，将装箱后的对象转换为值类型的过程，它是一种<strong>显式转换</strong>  </p><p>拆箱示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">3</span> ; </span><br><span class="line"><span class="built_in">object</span> oi = i ; </span><br><span class="line"><span class="built_in">int</span> j = (<span class="built_in">int</span>)oi;  <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h2 id="自定义转换"><a href="#自定义转换" class="headerlink" title="自定义转换"></a>自定义转换</h2><p>自定义转换就是为自己的结果或者类，定义显式和隐式转换    </p><blockquote><p>目的:为了让我们自己的结构或者类可以变成一个预期的相关的类型，并且是这种转换更加简单</p></blockquote><h3 id="隐式转换语法"><a href="#隐式转换语法" class="headerlink" title="隐式转换语法"></a>隐式转换语法</h3><p>首先是必不可少的public 和static</p><p>其次是<code>implicit</code> 表明这是一个<strong>隐式</strong>的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另外，隐式转换的语法没有函数的名称，只有返回内容</span><br><span class="line"></span><br><span class="line">比如我们想要把Cat转换为Dog</span><br><span class="line">```C#</span><br><span class="line">public static implicit operator Dog (Cat cat)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式转换语法"><a href="#显式转换语法" class="headerlink" title="显式转换语法"></a>显式转换语法</h3><p>和隐式转换的语法几乎一致<br>其关键字是 <code>explicit</code>   </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Dog</span> (<span class="params">Cat cat</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>利用现有的某种运算符，针对自定义类或者自定义结构，定义某种运算操作<br>1.不能创造新的运算符<br>2.预定义类型和现有运算符的运算含义是确定的</p><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>利用现有运算符，简化自定义类型的操作<br>最好是该运算符和该操作，具有一定的相关性(比如公狗+母狗&#x3D;小狗)</p><h3 id="语法细节"><a href="#语法细节" class="headerlink" title="语法细节"></a>语法细节</h3><p>比如我们想要重载一个对于狗的加法运算</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="keyword">operator</span> +(Dog male , Dog female)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可以重载的操作符："><a href="#可以重载的操作符：" class="headerlink" title="可以重载的操作符："></a>可以重载的操作符：</h4><p><strong>一元运算符</strong>:+,-,!,~,++,–,true,false<br><strong>二元运算符</strong>:+,-,*,&#x2F;,%,&amp;,|!,^,&lt;&lt;,&gt;&gt;，&#x3D;&#x3D;，!&#x3D;,&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;</p><blockquote><p>不能重载: &#x3D; ，&amp;&amp;，||，[],()</p></blockquote><h4 id="重载运算符不能够做什么"><a href="#重载运算符不能够做什么" class="headerlink" title="重载运算符不能够做什么"></a>重载运算符不能够做什么</h4><p>(注意这里是“不能做什么”)<br>创造新运算符<br>改变运算符的语法<br>重定义运算符如何处理预定义类型(比如不能把int a + int b 改为 a-b)<br>改变运算符的优先级和结合性  </p>]]></content>
    
    
    <summary type="html">对于C#的学习，一般用于Unity使用者的补强比较好</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>C#基础学习(四)</title>
    <link href="http://example.com/2022/02/07/C#%E5%AD%A6%E4%B9%A0_%E5%9B%9B/"/>
    <id>http://example.com/2022/02/07/C#%E5%AD%A6%E4%B9%A0_%E5%9B%9B/</id>
    <published>2022-02-06T16:00:00.000Z</published>
    <updated>2022-08-12T07:48:07.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><h2 id="初介绍委托"><a href="#初介绍委托" class="headerlink" title="初介绍委托"></a>初介绍委托</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>委托就是<strong>持有一个或多个方法</strong>的对象，并且该对象<strong>可以执行</strong>，也可以<strong>传递</strong><br>委托可以持有方法<br>委托可以<strong>声明</strong>，因为它实际上是一种引用类型<br><code>delegate void ActCute();</code><br>而且委托作为类型，我们就可以定义该类型的对象<br><code>ActCute actCute ; </code><br>定义了一种委托类型，这种委托接受的是<strong>没有返回值且没有参数</strong>的方法  </p><h3 id="给委托对象赋值"><a href="#给委托对象赋值" class="headerlink" title="给委托对象赋值"></a>给委托对象赋值</h3><p>利用<code>=</code>和之后会说的<code>+=</code>进行赋值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WagTail</span>()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">actCute = dog.WagTail ;  <span class="comment">//注意赋值和调用是不一样的：这里不需要()</span></span><br></pre></td></tr></table></figure><h3 id="使用委托对象"><a href="#使用委托对象" class="headerlink" title="使用委托对象"></a>使用委托对象</h3><p>就像<strong>调用函数对象</strong>一样使用委托<br><code>actCute();</code><br>并且委托可能持有多个方法，我们调用一次这个委托，就相当于调用了所有它所持有的方法<br>第一个方法利用<code>=</code>添加，第二个使用<code>+=</code>添加   </p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>可以利用delegate关键字，直接声明匿名方法给委托:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">ActCute</span>()</span>;</span><br><span class="line">ActCute del ; </span><br><span class="line">del = <span class="built_in">delegate</span>()&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>而<strong>Lambda表达式</strong>就是一种简化这种写法的方法    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">ActCute</span>()</span>;</span><br><span class="line">ActCute del ; </span><br><span class="line">del = () =&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布-订阅"></a>发布-订阅</h3><p>通知某件事情发生的，就是<strong>发布者</strong><br>对某件事情的发生关注的，就是<strong>订阅者</strong>  </p><p>当事件发生时，会通知所有关注该事件订阅者<br>想在事件发生的时候<strong>被通知</strong>，就必须注册来表示关注  </p><blockquote><p>用程序的语言来说，就是事件发生时，通知订阅者，就是调用订阅者的<strong>注册函数</strong>。注册，就是告诉发布者调用<strong>哪一个注册函数</strong>(告知调用函数&#x2F;回调函数)<br>事件，本质上和“观察者模式”是相同的</p></blockquote><h3 id="事件声明"><a href="#事件声明" class="headerlink" title="事件声明"></a>事件声明</h3><p>因为事件触发的时候，实质上就是<strong>调用一系列订阅者的注册函数</strong>的事情，而我们利用委托就可以很好地完成这件事情<br>使用<code>event</code>关键字来声明</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Handler</span>()</span>;</span><br><span class="line"><span class="keyword">public</span> evnet Handler NewDog;</span><br></pre></td></tr></table></figure><p>(NewDog是一个成员，并且会被隐式自动初始化为null)</p><h3 id="事件订阅"><a href="#事件订阅" class="headerlink" title="事件订阅"></a>事件订阅</h3><p>事件 +&#x3D; 方法 (订阅)<br>事件 -&#x3D; 方法 (取消订阅)<br>方法可以是实例方法、静态方法、匿名方法、Lambda表达式    </p><h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(NewDog != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//先检测是不是有人订阅</span></span><br><span class="line">    NewDog();</span><br><span class="line">    <span class="comment">//如果有，就通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>事件可以理解成是一种<strong>封装的、受限制的委托</strong>    </p><p><img src="https://i.loli.net/2021/11/10/Ijtf1TDKsZVRpGa.png">  </p><h1 id="小补充"><a href="#小补充" class="headerlink" title="小补充"></a>小补充</h1><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>记录特殊的，我们想要自定义的类型，增加代码可读性(实质上是int  i &#x3D; 0 ; 的效果是一样的)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> RoleType&#123;</span><br><span class="line">    <span class="comment">//写出取值</span></span><br><span class="line">    Mag,</span><br><span class="line">    Soldier,</span><br><span class="line">    Wizard</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以直接使用枚举类型来声明变量了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoleType rt = RoleType.Mag ; </span><br><span class="line">rt = RoleType.Solider ; <span class="comment">//重新赋值</span></span><br></pre></td></tr></table></figure><p>实际使用例  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HeroType heroType = HeroType.Soldier ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(heroType == HeroType.Soldier)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(heroType == HerpType.Mag)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(heroType == HetrType.Wizard)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然枚举类型大大加强了可读性</p><h2 id="for-each"><a href="#for-each" class="headerlink" title="for each"></a>for each</h2><p>专门进行遍历的方式</p><p>foreach(类型 寻找的变量名 in 数组)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transform[] children = tranform.GetComponentsInChildren&lt;Transform&gt;() ; </span><br><span class="line"><span class="keyword">foreach</span>(Transform t <span class="keyword">in</span> children)&#123;</span><br><span class="line">    <span class="comment">//每次循环中,t就代表从children里面得到的，某一次循环的t</span></span><br><span class="line">    <span class="comment">//这里就是每一个存储起来的Transform</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="脚本结构与组件"><a href="#脚本结构与组件" class="headerlink" title="脚本结构与组件"></a>脚本结构与组件</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>使用命名空间来更好的管理，使用<code>using</code>关键字来导入对应空间<br>如果命名空间未被导入，则其中的东西不能被使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine ; </span><br><span class="line"><span class="keyword">using</span> MyGame ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span>&#123;</span><br><span class="line">        GameData date ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GameDate</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Editor与脚本"><a href="#Editor与脚本" class="headerlink" title="Editor与脚本"></a>Editor与脚本</h3><p>运行时是以Editor中的数值为准的<br>比如Editor中，Hp&#x3D;100,代码中，Hp&#x3D;200,则最终运行时的的Hp是100</p><h3 id="组件获取"><a href="#组件获取" class="headerlink" title="组件获取"></a>组件获取</h3><p>想要获取自身挂载的组件，直接利用<code>GetComponent&lt;T&gt;()</code>即可<br>比如<code>Transform t = GetComponent&lt;Transform&gt;()</code>   </p><p>而<code>GetComponents&lt;T&gt;()</code>是获得一系列<strong>相同的属性</strong>，返回的是一个<strong>数组</strong>  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cillider[] colliders = GetComponents&lt;Collider&gt;();</span><br><span class="line"><span class="keyword">foreach</span>(Collider c <span class="keyword">in</span> colliders)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似的，使用<code>GetComponentInChildren</code>和<code>GetComponentInParent</code>来获得子&#x2F;父物体的组件   </p><blockquote><p>如果有多个相同类型的物体而使用GetComponent的话，就得到第一个符合条件的组件    </p></blockquote><h3 id="组件相关"><a href="#组件相关" class="headerlink" title="组件相关"></a>组件相关</h3><p>组件即使被禁用了，其中的方法依然可以被调用<br>如果想要访问组件中的某个元素，则如对class一样访问它即可 </p><h3 id="游戏物体获取"><a href="#游戏物体获取" class="headerlink" title="游戏物体获取"></a>游戏物体获取</h3><p>1.直接拖拽(拖拽的物体必须含有对应的组件)</p><p>2.使用transform.Find()查找<br><code>transform.Find(“XXXXXX”)</code>，其中XXXXXX代表的就是寻找的路径，指的是编辑器中的路径<br>但是这种方法只能得到子物体(子子物体等也行)，而且有比较大的性能消耗  </p><p>3.GameObject.Find(“物体名”)<br>通过名字来寻找，如果名字有多个重名，则得到第一个    </p><blockquote><p>遍历范围大，消耗也大</p></blockquote><p>4.标签tag<br><code>transform.FindWithTag(&quot;标签&quot;)</code>通过标签进行查找<br><code>GameObject player = transform.FindWithTag(&quot;Player&quot;)</code>   </p><p>比 利用名字搜索快很多</p>]]></content>
    
    
    <summary type="html">对于C#的学习，一般用于Unity使用者的补强比较好</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式：简单工厂与工厂方法</title>
    <link href="http://example.com/2022/02/07/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/02/07/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-02-06T16:00:00.000Z</published>
    <updated>2022-02-07T07:51:22.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>核心在于实现了<strong>创建者和调用者</strong>的分离<br>详细可以分为简单工厂模式、工厂方法模式、抽象工厂模式    </p><blockquote><p>抽象工厂模式在专门的笔记中    </p></blockquote><p>对应的三个原则是：<br>开闭原则:一个软件的实体应当对外扩展开放，对修改关闭<br>依赖倒转原则：要针对接口编程，不要针对实现编程<br>迪米特法则：只与你直接的朋友通信，避免和陌生人通信  </p><h2 id="核心本质与简介"><a href="#核心本质与简介" class="headerlink" title="核心本质与简介"></a>核心本质与简介</h2><p>本质：<br>1.不使用<code>new</code>来实例化对象，转而使用工厂方法代替<br>2.将选择实现类，创建对象统一管理和控制。从而将调用者和实现类解耦    </p><p>简单工厂：用来生产同一等级结构中的任意产品(对于增加新的产品，需要修改已有的代码)<br>工厂方法：用来生产同一等级结构中的固定产品<br>抽象工厂：围绕一个超级工厂来创建其他工厂，这个超级工厂又称为其他工厂的工厂  </p><h3 id="简单工厂-x2F-静态工厂"><a href="#简单工厂-x2F-静态工厂" class="headerlink" title="简单工厂&#x2F;静态工厂"></a>简单工厂&#x2F;静态工厂</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>核心在于<strong>实现在工厂中，使用者只需要调用</strong><br>比如说我要造车</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wulin</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;五菱宏光&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我建造一个简单工厂，由它负责实现<strong>如何造车</strong>，而另外一端的使用者只需要知道自己要什么车即可      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="comment">//Car的工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(String carName)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(carName.equals(<span class="string">&quot;Wulin&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Wulin</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carName.equals(<span class="string">&quot;Tesla&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//自行new</span></span><br><span class="line">    <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wulin</span>();</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用工厂创建!</span></span><br><span class="line">    <span class="type">Car</span> <span class="variable">car3</span> <span class="operator">=</span>  CarFactory.getCar(<span class="string">&quot;Wulin&quot;</span>) ;</span><br><span class="line">    <span class="comment">//我们并不关心细节,则可以直接利用工厂调出要的car</span></span><br><span class="line">    <span class="comment">//而实现创建的步骤则在工厂中实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>实际上，这并没有很好地对应开闭原则，毕竟每加一个类型，我们都要去修改工厂中的相关方法<br>这也是简单工厂也叫静态工厂的原因：里面的方法都是静态的，通过接受的参数来返回不同的结果<br>这也导致了它不修改代码，就不能增加新产品    </p><blockquote><p>不过大部分时候是没有关系的，如果想要实现开闭原则，则需要付出更大的代价，那就是工厂方法模式了  </p></blockquote><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式的代码量增加，但是它的横向扩展性极强，满足了开闭原则    </p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>我们保留之前的Car接口，Wulin类和Tesla类<br>此时，我们不直接使用工厂，而是将工厂设置为一个接口，并让每一种车<strong>各自的工厂</strong>来<strong>实现这个接口</strong>    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂方法模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory_Method</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个拿到车的方法,于是之后使用这个接口的类都要有这个方法了，之后把各种车的工厂分开，并实现这个接口</span></span><br><span class="line">    Car <span class="title function_">getCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeslaFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory_Method</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在该工厂中即可得到我们的Tesla</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WulinFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory_Method</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wulin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，我们就可以利用各个工厂得到各个车</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//自行new</span></span><br><span class="line">    <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wulin</span>();</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用简单工厂创建!</span></span><br><span class="line">    <span class="type">Car</span> <span class="variable">car3</span> <span class="operator">=</span>  CarFactory.getCar(<span class="string">&quot;Wulin&quot;</span>) ;</span><br><span class="line">    <span class="comment">//我们并不关心细节,则可以直接利用工厂调出要的car</span></span><br><span class="line">    <span class="comment">//而实现创建的步骤则在工厂中实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用工厂方法模式</span></span><br><span class="line">    <span class="type">Car</span> <span class="variable">car4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WulinFactory</span>().getCar();</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeslaFactory</span>().getCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的优势在哪呢，优势就在扩展，比如说我现在想加入一个新车，大众车<br>我们需要两步<br>1.写这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaZhong</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大众&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.写它的工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaZhongFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory_Method</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DaZhong</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是测试代码就又多了一种车，而这个过程中我们并没有修改之前的代码    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaZhongFactory</span>().getCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><p>和简单工厂相比，它的代码量很多很多，而且随着种类的增加，类也在增加<br>但是它带来的好处是不用修改原工厂代码，横向扩展简单</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>实际上个人认为，简单工厂就够了，即使它不完全符合开闭原则<br>结构复杂度：简单工厂<br>代码复杂度：简单工厂<br>编程复杂度：简单工厂<br>管理复杂度：简单工厂    </p><p>但工厂方法实现了原则    </p><p>然而，在实际开发中，简单工厂的优势巨大，而开闭原则在这种情况并不一定要遵守，死遵守原则带来的代价往往高于简单工厂<br>所以，大部分时候还是简单工厂吧！</p><blockquote><p>虽然有的时候要看原则，但是更多时候需要据情况考虑，而非只看原则规则。规则原则是死的，人是活的</p></blockquote>]]></content>
    
    
    <summary type="html">设计模式中的简单工厂模式的笔记</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C#基础学习(一)</title>
    <link href="http://example.com/2022/02/06/C#%E5%AD%A6%E4%B9%A0_%E4%B8%80/"/>
    <id>http://example.com/2022/02/06/C#%E5%AD%A6%E4%B9%A0_%E4%B8%80/</id>
    <published>2022-02-05T16:00:00.000Z</published>
    <updated>2022-08-12T07:48:10.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-0继承：虚、多态、抽象、密闭、接口、结构和类"><a href="#1-0继承：虚、多态、抽象、密闭、接口、结构和类" class="headerlink" title="1.0继承：虚、多态、抽象、密闭、接口、结构和类"></a>1.0继承：虚、多态、抽象、密闭、接口、结构和类</h1><p>这部分内容主要是规范，方便各种类&#x2F;方法&#x2F;结构 在使用中的分类<br>提高了代码的整洁度和优美，而且一定程度对降低代码耦合性也有帮助<br>因此放在了一起</p><h2 id="继承派生、虚方法、多态"><a href="#继承派生、虚方法、多态" class="headerlink" title="继承派生、虚方法、多态"></a>继承派生、虚方法、多态</h2><h3 id="设计原则——依赖倒置原则"><a href="#设计原则——依赖倒置原则" class="headerlink" title="设计原则——依赖倒置原则"></a>设计原则——依赖倒置原则</h3><p>程序设计套依赖于抽象类，而不依赖于具体类  </p><h3 id="基类派生类的引用"><a href="#基类派生类的引用" class="headerlink" title="基类派生类的引用"></a>基类派生类的引用</h3><p>可以引用基类来创建一个派生类的对象  </p><blockquote><p>派生类的对象包含基类部分和派生类部分<br>我们可以通过一个<strong>基类类型</strong>的引用指向派生类<br>通过这种方式的指向，<strong>我们只能访问派生类中的基类部分</strong> </p></blockquote><blockquote><p>相当于就是你用基类的模子整了一个派生类出来    </p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pet Dog = <span class="keyword">new</span> Dog();</span><br></pre></td></tr></table></figure><p>比如此时我调用了基类和派生类都有的一个方法Name()<br>本来基类的Name()应该被隐藏而调用派生类新的Name()方法<br>但是因为此时我们是利用了基类的引用而创建了该对象，所以我们只能访问基类的部分<br>因此调用的还是基类的方法  </p><h3 id="虚方法与多态"><a href="#虚方法与多态" class="headerlink" title="虚方法与多态"></a>虚方法与多态</h3><p>虚方法：声明为<strong>vitrual</strong>的方法就是虚方法。基类的虚方法可以在派生类中使用<strong>override</strong>进行重写  </p><p>多态：通过指向派生类的<strong>基类引用</strong>，调用<strong>虚函数</strong>。根据引用所指向派生类的实际类型，调用派生类中的<strong>同名重写函数</strong>  </p><p>在利用虚方法和多态时，对于基类的引用时，如果你调用了一个方法<br>会先判断一个方法是否是虚方法，如果是，则会查找对应的对象是否有override的方法<br>如果有，则执行override方法，否则就执行基类的那个方法  </p><p>这个是虚方法和抽象方法(见后文)在使用上的主要区别，本质上就一句话： <strong>如果有override，则使用；否则使用原来的方法</strong> </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>重写虚方法必须有相同的可访问性，且基类方法不能是private<br>不能重写<strong>非虚方法</strong> (这一点和一些语言不一样)<br>不能重写static方法<br>方法，属性，索引器，事件。都可以<strong>声明为vitrual 或者override</strong>  </p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>抽象方法是不可以有函数体的，只存在声明<br><code>abstract public void func()</code></p><blockquote><p>对于虚方法而言，基类的方法仍然可用（只有子类重写了才用子类的）。而对于抽象类而言则不行。</p></blockquote><p>换言之，想要用抽象方法，<strong>必须</strong>在子类中重写<br>我在基类中设置了这个东西，在子类中要且必须要得到实现    </p><h3 id="抽象成员、抽象类"><a href="#抽象成员、抽象类" class="headerlink" title="抽象成员、抽象类"></a>抽象成员、抽象类</h3><p>1.必须是<strong>方法、属性、事件、索引</strong><br>2.使用<strong>abstract</strong> 修饰符标记<br>3.不能有实现代码块</p><p>如果一个类被abstract标记，那么它就是抽象类  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>1.抽象类的存在只有一个目的，就是<strong>被继承</strong><br>2.抽象类不能被实例化，只能被abstract修饰<br>3.抽象类可以包含抽象成员和普通成员，以及他们的任意组合<br>4.抽象类的抽象成员在派生类中需要用<strong>override关键词</strong>实现    </p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pet</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>&#123;</span><br><span class="line">        实现...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="密闭"><a href="#密闭" class="headerlink" title="密闭"></a>密闭</h2><h3 id="sealed"><a href="#sealed" class="headerlink" title="sealed"></a>sealed</h3><p>密闭类:<br>声明为sealed的类<br>不希望其他人通过<strong>继承来修改</strong>的类</p><p>密闭方法:<br>声明为sealed的方法<br>不希望其他人<strong>重写</strong>该方法</p><blockquote><p>如果一个基类方法<strong>不希望</strong>子类对其重写，就可以不声明为virtual<br>如果某个派生类方法不希望子类对其重写，就可以使用sealed机制</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>接口就是指定一组函数成员，而<strong>不实现</strong>他们的引用类型    </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ICatchMice</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一般名字以I开头，约定俗成的命名方式</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CatchMice</span>()</span>; </span><br><span class="line">    <span class="comment">//默认就是public 但不能加任何修饰符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说比“抽象类还抽象”，有点像完全没有普通函数和数据的抽象类<br><strong>接口只能被实现</strong></p><p>一般来说，接口就是拿去被继承的，也就是说<strong>被别人实现的</strong>，就像抽象类只能被用来继承  </p><blockquote><p>接口就是定义了一个标准：“你需要实现什么事情”，而拿走这个接口的类，就需要完成这个任务</p></blockquote><h4 id="接口也是一种引用类型"><a href="#接口也是一种引用类型" class="headerlink" title="接口也是一种引用类型"></a>接口也是一种引用类型</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">ICatchMice ic = (ICatchMice)c ;</span><br><span class="line"></span><br><span class="line">c.CatchMice(); <span class="comment">//通过对象调用</span></span><br><span class="line">ic.CatchMice(); <span class="comment">//通过接口调用</span></span><br></pre></td></tr></table></figure><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><p>与抽象类相比，接口<strong>可以实现多个接口</strong><br>我们知道，一个类只能继承与<strong>一个父类</strong>，但是一个类可以<strong>实现多个接口</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cat : Pet,ICatchMice,IClimbTree</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CatchRat</span>()</span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClimbTress</span>()</span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的Pet是<strong>基类&#x2F;父类</strong>，而ICatchMice,IClimbTree是<strong>接口</strong></p><blockquote><p>放在第一位的是<strong>基类</strong>，后面接上接口</p></blockquote><blockquote><p>无论是在接口那里实现了功能，还是在调用接口的时候忘记实现了功能（没实现接口成员），均会报错  </p></blockquote><h2 id="结构和类"><a href="#结构和类" class="headerlink" title="结构和类"></a>结构和类</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> fish</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> weight ; </span><br><span class="line">    <span class="built_in">int</span> size ; </span><br><span class="line">    <span class="built_in">int</span> type ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>结构体是值类型(在栈中)，类是引用类型(在堆中)<br>结构体不支持继承，类支持继承。结构虽然不支持继承但是支持接口<br>结构体不能定义默认构造函数，编译器会定义(结构有构造函数，但不是我们定义的)</p><h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p><strong>结构</strong><br>分配内存快，作用域结束即被删除，不需要垃圾回收<br>作用于小型数据结构<br>不过，在传递过程中会复制，应该使用ref提高效率</p><p><strong>类</strong><br>用于其他的需要继承体系的场合</p>]]></content>
    
    
    <summary type="html">对于C#的学习，一般用于Unity使用者的补强比较好</summary>
    
    
    
    <category term="语言学习" scheme="http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2022/01/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-01-30T08:55:23.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>单例，就是单个实例的意思，一般用于只需要一个实例的场景<br>典型的例子就是各种Mgr，以及游戏的角色操控   </p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>一般来说，单例模式有七种写法，下面一一列出  </p><h3 id="1饿汉"><a href="#1饿汉" class="headerlink" title="1饿汉"></a>1饿汉</h3><p>类加载到内存后，就实例化一个单例，此时JVM会保证线程安全<br>简单实用，实用性强<br>唯一确定是不管是否被用到，在装载类的时候就会完成实例化</p><blockquote><p>但是如果你不用它，你装载啥啊  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mgr01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Mgr01</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mgr01</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Mgr01</span><span class="params">()</span>&#123;&#125;; <span class="comment">//这里的private保证了它不会被随随便便NEW出来 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个getInstance方法，想要得到它只能使用这个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Mgr01 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2饿汉改"><a href="#2饿汉改" class="headerlink" title="2饿汉改"></a>2饿汉改</h3><p>和第一个本质上没区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mgr02</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Mgr02 INSTANCE ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        INSATNCE = <span class="keyword">new</span> <span class="title class_">Mgr02</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Mgr02</span><span class="params">()</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Mgr02 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3懒汉式"><a href="#3懒汉式" class="headerlink" title="3懒汉式"></a>3懒汉式</h3><p>什么时候使用，就在什么时候初始化<br>缺点在于带来了多线程访问时的影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mgr03</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Mgr03 INSTANCE ; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Mgr03</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Mgr03 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Mgr03</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有需要，之前没初始化过，就得到它，否则就直接返回</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4加锁懒汉式"><a href="#4加锁懒汉式" class="headerlink" title="4加锁懒汉式"></a>4加锁懒汉式</h3><p>既然之前说多线程访问有影响，那么就加锁<br>这样下去，虽然可以通过synchronized解决，但是相应的，效率降低了  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mgr04</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Mgr04 INSTANCE ; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Mgr04</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Mgr04 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Mgr04</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有需要，之前没初始化过，就得到它，否则就直接返回</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5双重检查单例写法"><a href="#5双重检查单例写法" class="headerlink" title="5双重检查单例写法"></a>5双重检查单例写法</h3><p>完美的方法之一，利用两次检查保证安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mgr05</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span>  Mgr05 INSTANCE ; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Mgr05</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Mgr05 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span>(Mgr05.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Mgr05</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有需要，之前没初始化过，就得到它，否则就直接返回</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6静态内部类写法"><a href="#6静态内部类写法" class="headerlink" title="6静态内部类写法"></a>6静态内部类写法</h3><p>JVM保证单例<br>加载外部类的时候不会加载内部类，这样可以实现懒加载<br>完美的方法之二，而且简单好写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mgr06</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Mgr06</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Mgr06Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Mgr06</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mgr07</span>() ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Mgr06 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mgr06Holder.INSTANCE ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7ENUM"><a href="#7ENUM" class="headerlink" title="7ENUM"></a>7ENUM</h3><p>完美的方法其三<br>不仅解决了线程同步，还可以防止反序列化<br>EffectiveJava中的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Mgr07</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">设计模式中的单例模式的笔记</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
